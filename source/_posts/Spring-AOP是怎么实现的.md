---
title: Spring AOP是怎么实现的
top: false
cover: false
toc: true
mathjax: false
abbrlink: 1224
date: 2021-11-19 17:34:41
author:
img:
coverImg:
password:
summary:
categories:
  - 框架
tags:
  - Spring
---

## 概述
Spring的AOP实现是通过动态代理实现的。如果我们为Spring的一个bean配置了AOP切面，那么Spring在创建这个bean的时候，实际上创建的是这个bean的一个代理对象，我们后续对bean中方法的调用，实际上调用的是代理类重写的代理方法。

而Spring的AOP使用了两种动态代理，分别是
- JDK的动态代理；
- CGLib的动态代理。

### JDK动态代理
Spring默认使用JDK的动态代理实现AOP，类如果实现了接口，Spring就会使用这种方式实现动态代理。JDK实现动态代理需要两个组件
- 首先第一个就是InvocationHandler接口。我们在使用JDK的动态代理时，需要编写一个类，去实现这个接口，然后重写invoke方法，这个方法其实就是我们提供的代理方法。
- 然后JDK动态代理需要使用的第二个组件就是Proxy这个类，我们可以通过这个类的newProxyInstance方法，返回一个代理对象。生成的代理类实现了原来那个类的所有接口，并对接口的方法进行了代理，我们通过代理对象调用这些方法时，底层将通过反射，调用我们实现的invoke方法。

### CGLib动态代理
JDK的动态代理存在限制，那就是被代理的类必须是一个实现了接口的类，代理类需要实现相同的接口，代理接口中声明的方法。
- 若需要代理的类没有实现接口，此时JDK的动态代理将没有办法使用，于是Spring会使用CGLib的动态代理来生成代理对象。
- CGLib直接操作字节码，生成类的子类，重写类的方法完成代理。


## JDK的动态代理
### 原理

  JDK的动态代理是基于反射实现。JDK通过反射，生成一个代理类，这个代理类实现了原来那个类的全部接口，并对接口中定义的所有方法进行了代理。当我们通过代理对象执行原来那个类的方法时，代理类底层会通过反射机制，回调我们实现的InvocationHandler接口的invoke方法。并且这个代理类是Proxy类的子类

### 优点
- JDK动态代理是JDK原生的，不需要任何依赖即可使用；
- 通过反射机制生成代理类的速度要比CGLib操作字节码生成代理类的速度更快；
### 缺点
- 如果要使用JDK动态代理，被代理的类必须实现了接口，否则无法代理；
- JDK动态代理无法为没有在接口中定义的方法实现代理，假设我们有一个实现了接口的类，我们为它的一个不属于接口中的方法配置了切面，Spring仍然会使用JDK的动态代理，但是由于配置了切面的方法不属于接口，为这个方法配置的切面将不会被织入。
- JDK动态代理执行代理方法时，需要通过反射机制进行回调，此时方法执行的效率比较低；

## CGLib动态代理

### 原理

CGLib实现动态代理的原理是，底层采用了ASM字节码生成框架，直接对需要代理的类的字节码进行操作，生成这个类的一个子类，并重写了类的所有可以重写的方法，在重写的过程中，将我们定义的额外的逻辑（切面）织入到方法中，对方法进行了增强。

通过字节码操作生成的代理类，和我们自己编写并编译后的类没有什么区别。

### 优点
- 使用CGLib代理的类，不需要实现接口，因为CGLib生成的代理类是直接继承自需要被代理的类；
- CGLib生成的代理类是原来那个类的子类，这就意味着这个代理类可以为原来那个类中，所有能够被子类重写的方法进行代理；
- CGLib生成的代理类，和我们自己编写并编译的类没有太大区别，对方法的调用和直接调用普通类的方式一致，所以CGLib执行代理方法的效率要高于JDK的动态代理；

### 缺点
- 由于CGLib的代理类使用的是继承，这也就意味着如果需要被代理的类是一个final类，则无法使用CGLib代理；
- 由于CGLib实现代理方法的方式是重写父类的方法，所以无法对final方法，或者private方法进行代理，因为子类无法重写这些方法；
- CGLib生成代理类的方式是通过操作字节码，这种方式生成代理类的速度要比JDK通过反射生成代理类的速度更慢；





