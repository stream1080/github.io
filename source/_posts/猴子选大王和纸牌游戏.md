---
title: 猴子选大王和纸牌游戏
top: false
cover: false
toc: true
mathjax: false
abbrlink: 61103
date: 2020-07-05 23:00:44
author:
img:
coverImg:
password:
summary:
categories:
  - 数据结构
tags:
  - C++
---


# 1.猴子选大王
一堆猴子都有编号，编号是1，2，3 ...m ,这群猴子（m个）按照1-m的顺序围坐一圈，从第1开始数，每数到第N个，该猴子就要离开此圈，这样依次下来，直到圈中只剩下最后一只猴子，则该猴子为大王。
## 要求
输入数据：输入m,n m,n 为整数，n<m
输出形式：中文提示按照m个猴子，数n 个数的方法，输出为大王的猴子是几号 ，建立一个函数来实现此功能 

## 数据结构设计
设计一个循环的单链表，使其可以一直循环数数，每数到N个即删除节点，最后留下了的即为大王

```
typedef struct LNode   
{
 	int data;
 	struct LNode *next;
}LinkNode;
```

## 流程设计
![在这里插入图片描述](https://img-blog.csdnimg.cn/20200704215455320.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Vwc3RyZWFtNDgw,size_16,color_FFFFFF,t_70)
1. 输入猴子个数m和间隔数n
2. 判断m，n是否合法，非法则重新输入，合法进入下一步
3. 建立一个带头节点的循环单链表，代表m个猴子围坐一圈
4. 遍历循环单链表，数到n的猴子退出，删除节点。重新计数
5. 当循环单链表中只剩下一只猴子是，即为大王。
6. 若输入的n为1，猴子依次退出，最后一个为大王

## 主要代码

```cpp
//设计一个循环单链表模拟猴子围坐在一圈
//数到的猴子退出，删除节点
//只剩下一个猴子时，即为大王 
int SelectKing()
{
 int m,n,i;//i为当前数到的数 
 
 while(1) 
 { 
  system("cls");
  cout<<endl<<"请输入猴子个数m(m为正整数)：";
  cin>>m;
  cout<<endl<<"输入间隔数n(n为正整数且m>n): ";
  cin>>n;
  if(m>0 && n>0 && m>n) 
   break; 
  else          //异常处理
   cout<<endl<<"输入错误，请重新输入"<<endl<<endl;
   system("pause");   
 }
 
 LinkNode *s,*r,*p,*L;
 LNode *q;
 L = new(LinkNode);
 r = L;
 for(int i=1;i<=m;i++)
 {
  s = new(LinkNode);
  s->data = i;
  r->next = s;
  r = s;
 }
 
 r->next = L->next; //创建循环单链表 
 
 p = L->next;
 i = 1;
 while(1)
 {
  if(i == n-1)//数到n的猴子退出 
  {
   q = p->next;
   p->next = q->next;
   cout<<endl<<"   第"<<q->data<<"个猴子退出,还剩"<<m-1<<"个猴子"<<endl; 
   delete q;    //猴子退出，删除节点 
   i=0;
   m--;
  }
  if(n==1)  //间隔数为1时，猴子依次退出，最后一个即为大王 
  {
   cout<<endl<<"   第"<<p->data<<"个猴子退出,还剩"<<m-1<<"个猴子"<<endl; 
   delete q;     //猴子退出，删除节点 
   i=0;
   m--;  
  } 
  i++;
  p = p->next;
  if(m==1)//链表中只剩下一个猴子即为大王 
  {
   cout<<endl<<" 选出第"<<p->data<<"个猴子为大王"<<endl<<endl;
   break;     //选出大王，退出循环 
  }
 }
}
```
## 测试结果
![在这里插入图片描述](https://img-blog.csdnimg.cn/20200704220158545.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Vwc3RyZWFtNDgw,size_16,color_FFFFFF,t_70)


# 2.纸牌游戏
编号为1-52张牌，正面向上，从第2张开始，以2为基数，是2的倍数的牌翻一次，直到最后一张牌；然后，从第3张开始，以3为基数，是3的倍数的牌翻一次，直到最后一张牌；然后…从第4张开始，以4为基数，是4的倍数的牌翻一次， 直到最后一张牌；...再依次5的倍数的牌翻一次，6的，7的 直到 以52为基数的 翻过，输出：这时正面向上的牌有哪些？
## 数据结构设计

```cpp
//设计一个长度为53的线性表，丢弃0节点
//1表示正面向上，0表示正面向下 
typedef struct
{
 int data[53];
 int lenght;
}Sqlist;

//把牌翻一次 
int swap(int i) 
{
 if(i == 0)
  return 1;
 else
  return 0; 
}

```

## 流程设计
![在这里插入图片描述](https://img-blog.csdnimg.cn/20200704221856217.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Vwc3RyZWFtNDgw,size_16,color_FFFFFF,t_70)

1. 创建一个长度为53的线性表，丢弃0节点，其他的节点赋值为1，代表正面向上
2. 编写一个翻转纸牌的函数，若纸牌为1则返回0。若纸牌为0则返回1
3. 编写两个循环嵌套，从第二张牌开始便利，以2的倍数翻转纸牌，直到最后一张牌。从3开始遍历，以3的倍数翻转纸牌，直到一52开始，翻转到最后一张
4. 输出正面向上的纸牌

## 程序代码

```cpp


void game()
{ 
 int i,j;
 Sqlist *L;
 L = new(Sqlist);
 L->lenght = 53;
 
 for(i=1;i<L->lenght;i++)
 { 
  L->data[i] = 1; //所有的牌赋为1表示正面向上 
 }
 
 for(i=2;i<L->lenght;i++)
 {
  for(j=i;j<L->lenght;j++) 
  {
   if(j%i == 0)
   {
    L->data[j] = swap(L->data[j]); //把牌翻一次 
   }
  }
 }
 j = 0; 
 
 cout<<endl<<" 正面向上的牌有：";
 for(i=0;i<L->lenght;i++)//输出正面向上的牌 
 { 
  if(L->data[i] == 1)
  { 
   cout<<i<<" ";
   j ++; 
  }
 }
 cout<<endl<<endl<<"     一共有 "<<j<<" 张正面向上的牌"<<endl<<endl; 
}
```
## 测试结果
![在这里插入图片描述](https://img-blog.csdnimg.cn/20200704222415802.png)

