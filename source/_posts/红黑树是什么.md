---
title: 红黑树是什么
cover: false
top: false
date: 2021-11-13 15:00:14
summary:
categories:
  - 数据结构
tags:
  - 红黑树
---

## 红黑树
红黑树是一种接近平衡的二叉搜索树，它能够保证任意一个节点左右子树的高度差不会超过较低子树的高度，也就是两棵子树的高度比值不会超过 2 倍。这样我们可以使搜索的时间复杂度更接近 O (logN)。为了保证树的平衡，我们需要在添加或删除元素的时候不断的调整树的结构，使每个节点的左右子树上的节点个数尽可能相等。

## 红黑树的性质
- 每个节点不是红色就是黑色；
- 根节点永远是黑色；
- 红色节点的子节点必须是黑色；
- 任意一个节点到每个叶子节点的路径上都包含相同数量的黑色节点；
- 每次添加新节点都默认为红色。

## 红黑树调整的方式
如果每次添加节点都设置为红色，当父节点已经是红色时，会违背上面的第 3 条性质，这时候我们需要按照一定的方法去调整树，调整的方式有三种：
- 改变节点颜色
- 左旋
- 右旋。

#### 变色
改变节点颜色如下图，我们依次做了以下尝试：
- ①默认红色：违反性质 3；
- ②默认黑色：违反性质 4；
- ③默认红色，将父节点和父节点的兄弟节点改为黑色，满足全部 5 条性质。

#### 左旋
拎起左旋节点的右子节点，使左旋节点向左下沉，成为右子节点的左子节点，右子节点上升成为其父节点。
#### 右旋
拎起右旋节点的左子节点，使右旋节点向右下沉，成为左子节点的右子节点，左子节点上升成为其父节点。
## 红黑树的插入操作
插入元素会导致原本平衡的红黑树失去平衡，还会导致红黑树五大特性的不满足。因此插入后我们需要做调整，使其重新成为一个红黑树。

#### 寻找插入位置
把元素插进红黑树的第一步是找到要插入的位置。寻找位置的方法其实也比较简单：
- ①如果是空树，直接插入到跟节点；
- ②如果与当前节点的 key 值相等，则更新当前节点的 value 值；
- ③如果比当前节点的 key 值大，则继续寻找当前节点的右子节点；
- ④如果比当前节点的 key 值小，则继续寻找当前节点的左子节点；
- ⑤如果当前节点为 null（或 nil 节点），则插入在当前节点的父节点下。

## 自平衡
红黑树的自平衡较为复杂

```java
   static <K,V> TreeNode<K,V> balanceInsertion(TreeNode<K,V> root, TreeNode<K,V> x) {
       x.red = true;
       for (TreeNode<K,V> xp, xpp, xppl, xppr;;) {
           //false条件：当前节点存在父节点
           if ((xp = x.parent) == null) {
               //父节点为空，当前节点是根节点，直接设置根节点为黑色后返回
               x.red = false;
               return x;
           }
           //false条件：且父节点是红色，且存在爷爷节点
           else if (!xp.red || (xpp = xp.parent) == null)
               return root;
           if (xp == (xppl = xpp.left)) {
               //false条件：且叔叔节点为空，或者是黑色；
               if ((xppr = xpp.right) != null && xppr.red) {
                   xppr.red = false;
                   xp.red = false;
                   xpp.red = true;
                   x = xpp;
               }
               else {
                   //true条件：当前节点是其父节点的右子节点；
                   if (x == xp.right) {
                       // 左旋父节点
                       root = rotateLeft(root, x = xp);
                       // 爷爷节点不存在则结束，存在则将指针指向父节点
                       xpp = (xp = x.parent) == null ? null : xp.parent;
                   }
                   // true条件：父节点不为空
                   if (xp != null) {
                       // 父节点变为黑色
                       xp.red = false;
                       // true条件：祖父节点不为空
                       if (xpp != null) {
                           // 祖父节点变为红色
                           xpp.red = true;
                           // 右旋祖父节点
                           root = rotateRight(root, xpp);
                       }
                   }
               }
           }
           else {
               //false条件：且叔叔节点为空，或者是黑色；
               if (xppl != null && xppl.red) {
                   // 当前节点的父节点以及左叔父节点都是红色 则颜色变为黑色
                   xppl.red = false;
                   xp.red = false;
                   // 黑节点的父节点必须红色
                   xpp.red = true;
                   x = xpp;
               }
               else {
                   //true条件：当前节点是其父节点的左子节点；
                   if (x == xp.left) {
                       // 右旋父节点
                       root = rotateRight(root, x = xp);
                       // 指针指向父节点
                       xpp = (xp = x.parent) == null ? null : xp.parent;
                   }
                   // true条件：父节点不为空
                   if (xp != null) {
                       // 父节点变为黑色
                       xp.red = false;
                       // true条件：祖父节点不为空
                       if (xpp != null) {
                           // 祖父节点变为红色
                           xpp.red = true;
                           //  右旋祖父节点
                           root = rotateLeft(root, xpp);
                       }
                   }
               }
           }
       }
   }

```

## 红黑树的删除操作
删除操作可能触发的情况分为有子节点和无子节点
- 没有子节点的情况非常简单，直接删除后执行自平衡即可；
- 有子节点的时候我们要先找到替换节点，如果只有一个子节点，这个节点就是替换节点；
- 如果有两个子节点，要找到左子树的最大节点或右子树的最小节点作为替换节点。
