---
title: 扩展线程池捕获线程异常
cover: false
top: false
date: 2021-09-15 21:12:28
summary:
categories:
  - 多线程
tags:
  - 线程池
---

## 如何捕获线程池中的线程异常
### 简单案例
我们先看一个案例，实现Runnable接口，计算两个数的商
![在这里插入图片描述](https://img-blog.csdnimg.cn/412d931173c34e70ae14e23a7236c8cb.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5LiA5rGf5rqq5rC0,size_20,color_FFFFFF,t_70,g_se,x_16)
创建一个线程池，参数如下
![在这里插入图片描述](https://img-blog.csdnimg.cn/a274f18d22894035b24ed64b36fe2835.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5LiA5rGf5rqq5rC0,size_20,color_FFFFFF,t_70,g_se,x_16)
提交任务到线程池，查看执行结果
![在这里插入图片描述](https://img-blog.csdnimg.cn/2cea315595974aab8d54688a7d456f14.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5LiA5rGf5rqq5rC0,size_20,color_FFFFFF,t_70,g_se,x_16)
执行结果
![在这里插入图片描述](https://img-blog.csdnimg.cn/c9999b695a714397aa4b35c320caef04.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5LiA5rGf5rqq5rC0,size_20,color_FFFFFF,t_70,g_se,x_16)
- 我们发现，我们代码中，提交了5个线程，但最终只打印了4个结果，
- 而且没有报何错误，很明显100/0的那个任务没有打印
- 100/0会报除零异常，但是显然这次没有报任何错误

### 改用execute()提交线程
为了获得线程报错信息，我们可以改用execute()提交线程
![在这里插入图片描述](https://img-blog.csdnimg.cn/0066bbf997c746beae88e10f83264575.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5LiA5rGf5rqq5rC0,size_20,color_FFFFFF,t_70,g_se,x_16)
- 从这里的控制台，我们得到了部分的报错信息，但是我们只能知道异常是在哪里抛出来的，ThreadPoolTest.java的第51行；
- 但是我们还是希望得到其他的更重要的信息，这个任务在哪里提交的？
### 扩展线程池ThreadPoolExecutor
我们可以扩展一下ThreadPoolExecutor这个线程池，让他在任务调度前，先保存一下提交任务线程的堆栈信息

```java
package com.stream.juc;

import java.util.concurrent.BlockingQueue;
import java.util.concurrent.Future;
import java.util.concurrent.ThreadPoolExecutor;
import java.util.concurrent.TimeUnit;

/**
 * 扩展线程池
 * 捕获线程池的异常
 *
 * @author stream
 * @since 2021/9/15 7:51
 */
class ExtenThreadPoolExecutor extends ThreadPoolExecutor {

    public ExtenThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue<Runnable> workQueue, CallerRunsPolicy callerRunsPolicy) {
        super(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue);
    }

    @Override
    public void execute(Runnable command) {
        super.execute(wrap(command,clientTrace(),Thread.currentThread().getName()));
    }

    @Override
    public Future<?> submit(Runnable task) {
        return super.submit(wrap(task,clientTrace(),Thread.currentThread().getName()));
    }

	// 抛出异常信息
    private Exception clientTrace(){
        return new Exception("Thread Stack");
    }

    private Runnable wrap(Runnable task, Exception exception , String name) {
        return new Runnable() {
            @Override
            public void run() {
                try {
                    task.run(); // 捕获异常
                }catch (Exception e){
                    exception.printStackTrace();
                    throw e;
                }
            }
        };
    }
}

```
我们用扩展后的线程池提交任务，还是刚才的代码
![在这里插入图片描述](https://img-blog.csdnimg.cn/f585e3e0943b4c089071ef9f7df94552.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5LiA5rGf5rqq5rC0,size_20,color_FFFFFF,t_70,g_se,x_16)
这样，我们就得到了异常发生的内部堆栈信息，帮助我们快速定位问题
