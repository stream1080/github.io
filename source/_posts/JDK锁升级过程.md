---
title: JDK锁升级过程
top: false
cover: false
toc: true
mathjax: false
categories:
  - 多线程
tags:
  - 锁
abbrlink: 51919
date: 2021-12-26 00:13:54
author:
img:
coverImg:
password:
summary:
---


## synchronized
### Java对象头
synchronized是悲观锁，在操作同步资源之前需要给同步资源先加锁，这把锁就是存在Java对象头里的，对象头主要包括两部分数据：
- Mark Word（标记字段）
- Klass Pointer（类型指针）。

**Mark Word**
默认存储对象的HashCode，分代年龄和锁标志位信息。这些信息都是与对象自身定义无关的数据，所以Mark Word被设计成一个非固定的数据结构以便在极小的空间内存存储尽量多的数据。它会根据对象的状态复用自己的存储空间，也就是说在运行期间Mark Word里存储的数据会随着锁标志位的变化而变化。

**Klass Point**
对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。

### Monitor
Monitor可以理解为一个同步工具或一种同步机制，通常被描述为一个对象。每一个Java对象就有一把看不见的锁，称为内部锁或者Monitor锁。

Monitor是线程私有的数据结构，每一个线程都有一个可用monitor record列表，同时还有一个全局的可用列表。每一个被锁住的对象都会和一个monitor关联，同时monitor中有一个Owner字段存放拥有该锁的线程的唯一标识，表示该锁被这个线程占用。

## synchronized如何实现线程同步
synchronized通过Monitor来实现线程同步，Monitor是依赖于底层的操作系统的Mutex Lock（互斥锁）来实现的线程同步。
```
阻塞或唤醒一个Java线程需要操作系统切换CPU状态来完成，这种状态转换需要耗费处理器时间。
如果同步代码块中的内容过于简单，状态转换消耗的时间有可能比用户代码执行的时间还要长
```
- 这种方式就是synchronized最初实现同步的方式，这就是JDK 6之前synchronized效率低的原因。
- 这种依赖于操作系统Mutex Lock所实现的锁我们称之为“重量级锁”，JDK 6中为了减少获得锁和释放锁带来的性能消耗，引入了“偏向锁”和“轻量级锁”。


### 存储内容
|锁状态|	存储内容|	存储内容|
| --- | ---- | --- |
|无锁	|对象的hashCode、对象分代年龄、是否是偏向锁（0）	| 01|
|偏向锁	|偏向线程ID、偏向时间戳、对象分代年龄、是否是偏向锁（1）|	01|
|轻量级锁|	指向栈中锁记录的指针	|00
|重量级锁	| 指向互斥量（重量级锁）的指针|	10


## 锁的四种状态
锁的状态总共有四种，级别由低到高依次为：
- 无锁
- 偏向锁
- 轻量级锁
- 重量级锁

在JDK 1.6后，JVM为了提高锁的获取与释放效率，对synchronized 进行了优化，引入了 偏向锁 和 轻量级锁 ，从此以后锁的状态就有了四种（无锁、偏向锁、轻量级锁、重量级锁），

- 四种状态会随着竞争的情况逐渐升级，这是是不可逆的过程，即不可降级；
- 只能升级（从低级别到高级别），不能锁降级（高级别到低级别）；
- 意味着偏向锁升级成轻量级锁后不能降级成偏向锁；
- 这种锁升级却不能降级的策略，目的是为了提高获得锁和释放锁的效率。

![在这里插入图片描述](https://img-blog.csdnimg.cn/1dfc5bfb4f094c1696e611a4e5470630.png)
## 无锁

无锁没有对资源进行锁定，所有的线程都能访问并修改同一个资源，但同时只有一个线程能修改成功。


- 无锁的特点就是修改操作在循环内进行，线程会不断的尝试修改共享资源。
- 如果没有冲突就修改成功并退出，否则就会继续循环尝试。
- 如果有多个线程修改同一个值，必定会有一个线程能修改成功，而其他修改失败的线程会不断重试直到修改成功。
- 典型的应用就是CAS乐观锁，无锁无法全面代替有锁，但无锁在某些场景下的性能是非常高的。

## 偏向锁

偏向锁是指一段同步代码一直被一个线程所访问，那么该线程会自动获取锁，降低获取锁的代价。

在大多数情况下，锁总是由同一线程多次获得，不存在多线程竞争，所以出现了偏向锁。其目标就是在只有一个线程执行同步代码块时能够提高性能。不需要频繁的切换

当一个线程访问同步代码块并获取锁时，会在Mark Word里存储锁偏向的线程ID。在线程进入和退出同步块时不再通过CAS操作来加锁和解锁，而是检测Mark Word里是否存储着指向当前线程的偏向锁。引入偏向锁是为了在无多线程竞争的情况下尽量减少不必要的轻量级锁执行路径，因为轻量级锁的获取及释放依赖多次CAS原子指令，而偏向锁只需要在置换ThreadID的时候依赖一次CAS原子指令即可。

偏向锁只有遇到其他线程尝试竞争偏向锁时，持有偏向锁的线程才会释放锁，线程不会主动释放偏向锁。偏向锁的撤销，需要等待全局安全点（在这个时间点上没有字节码正在执行），它会首先暂停拥有偏向锁的线程，判断锁对象是否处于被锁定状态。撤销偏向锁后恢复到无锁（标志位为“01”）或轻量级锁（标志位为“00”）的状态。


## 轻量级锁

是指当锁是偏向锁的时候，被另外的线程所访问，偏向锁就会升级为轻量级锁，其他线程会通过自旋的形式尝试获取锁，不会阻塞，从而提高性能。

在代码进入同步块的时候，如果同步对象锁状态为无锁状态（锁标志位为“01”状态，是否为偏向锁为“0”），虚拟机首先将在当前线程的栈帧中建立一个名为锁记录（Lock Record）的空间，用于存储锁对象目前的Mark Word的拷贝，然后拷贝对象头中的Mark Word复制到锁记录中。

拷贝成功后，虚拟机将使用CAS操作尝试将对象的Mark Word更新为指向Lock Record的指针，并将Lock Record里的owner指针指向对象的Mark Word。

如果这个更新动作成功了，那么这个线程就拥有了该对象的锁，并且对象Mark Word的锁标志位设置为“00”，表示此对象处于轻量级锁定状态。

如果轻量级锁的更新操作失败了，虚拟机首先会检查对象的Mark Word是否指向当前线程的栈帧，如果是就说明当前线程已经拥有了这个对象的锁，那就可以直接进入同步块继续执行，否则说明多个线程竞争锁。

若当前只有一个等待线程，则该线程通过自旋进行等待。但是当自旋超过一定的次数，或者一个线程在持有锁，一个在自旋，又有第三个来访时，轻量级锁升级为重量级锁。

## 重量级锁

升级为重量级锁时，锁标志的状态值变为“10”，此时Mark Word中存储的是指向重量级锁的指针，此时等待锁的线程都会进入阻塞状态。



## 锁的升级过程
![在这里插入图片描述](https://img-blog.csdnimg.cn/5ef0ac3a2a034992839d3694edbc22f5.png)

- 无锁是实现了CAS思想，比如乐观锁
- 偏向锁通过对比Mark Word解决加锁问题，避免执行CAS操作。
- 轻量级锁是通过用CAS操作和自旋来解决加锁问题，避免线程阻塞和唤醒而影响性能。
- 重量级锁是将除了拥有锁的线程以外的线程都阻塞。
