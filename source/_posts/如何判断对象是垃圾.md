---
title: 如何判断对象是垃圾
top: false
cover: false
toc: true
mathjax: false
categories:
  - JVM
tags:
  - 垃圾回收
  - GC Root
abbrlink: 47877
date: 2021-08-16 23:09:01
author:
img:
coverImg:
password:
summary:
---

# 如何判断对象是否是垃圾
堆中几乎放着所有的对象实例，对堆垃圾回收前的第步就是要判断哪些对象已经死亡(即不能再被任
何途径使用的对象)，方便垃圾回收器对这些死亡的对象进行回收。
在说如果判断对象是否为垃圾前，我们需要了解一些其他概念

#### 垃圾回收器
JVM 为 Java 提供了垃圾回收机制，其实是一种偏自动的内存管理机制。简单来说，垃圾回收器会自动追踪所有正在使用的对象，并将其余未被使用的对象标记为垃圾，不需要开发者手动进行垃圾回收，JVM 自动进行垃圾回收，释放内容。
#### 垃圾回收
如果不进行垃圾回收，内存迟早都会被消耗空，因为我们在不断的分配内存空间而不进行回收。除非内存无限大，我们可以任性的分配不回收，但是事实并非如此。所以，垃圾回收是必须的。

#### 哪些内存需要回收
所谓“要回收的垃圾”无非就是那些不可能再被任何途径所使用的对象。无需再使用的对象，会被标记为垃圾，等待JVM回收此部分内存。

## 计数器法
- 在对象中添加一个引用计数器，如果被引用计数器加1，引用失效时计数器减1；
- 如果计数器为0则被标记为垃圾。
- 原理简单，效率高，但是在Java中很少使用，因为存在对象间循环引用的问题，导致计数器无法清零。
## 可达性分析
- 大多数语言的内存管理都使用可达性分析判断对象是否存活。
- 基本思路是通过一系列称为GC Roots的根对象作为起始节点集，
- 从这些节点开始，根据引用关系向下搜索，搜索过程走过的路径称为引用链，
- 如果某个对象到GC Roots没有任何引用链相连，则会被标记为垃圾。

在 Java 语言中，可以作为 GCRoots 的对象包括下面几种：

- 虚拟机栈（栈帧中的局部变量区，也叫局部变量表）中引用的对象；
- 方法区中的类静态变量属性引用的对象；
- 方法区中常量引用的对象；
- 本地方法栈中 JNI（Native方法）引用的对象。

图片中红色箭头指向的都是没有GC Root引用链的，均被判定为垃圾
![在这里插入图片描述](https://img-blog.csdnimg.cn/2ce6dccd389447baaea0d73705e42045.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Vwc3RyZWFtNDgw,size_16,color_FFFFFF,t_70)
### GC Root

#### 虚拟机栈中的引用的对象
在程序中创建一个对象，对象会在堆上开辟一块空间，同时会将这块空间的地址作为引用保存到虚拟机栈中，如果对象生命周期结束了，那么引用就会从虚拟机栈中出栈，因此如果在虚拟机栈中有引用，就说明这个对象还是有用的，这种情况是最常见的；

#### 全局的静态的对象
也就是使用了 static 关键字，由于虚拟机栈是线程私有的，所以这种对象的引用会保存在共有的方法区中，显然将方法区中的静态引用作为 GC Roots 是必须的；

#### 常量引用
就是使用了 static final 关键字，由于这种引用初始化之后不会修改，所以方法区常量池里的引用的对象也应该作为 GC Roots；

#### Native 方法引用对象
这一种是在使用 JNI 技术时，有时候单纯的 Java 代码并不能满足我们的需求，我们可能需要在 Java 中调用 C 或 C++ 的代码，因此会使用 native 方法，JVM 内存中专门有一块本地方法栈，用来保存这些对象的引用，所以本地方法栈中引用的对象也会被作为 GC Roots。

