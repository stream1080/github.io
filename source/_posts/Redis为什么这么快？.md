---
title: Redis为什么这么快？
top: false
cover: false
toc: true
mathjax: false
categories:
  - 缓存
tags:
  - Redis
abbrlink: 61826
date: 2021-12-04 20:50:10
author:
img:
coverImg:
password:
summary:
---

Redis经常被用作做缓存， 一致性要求不高的场景，还可以当做kv存储使用。

另外， Redis还提供了消息订阅、事务、索引等特性。
我们还可以利用集群特性搭建分布式存储服务，实现非强一致性的分布式锁服务。

Redis用到上述场景， 都有一个共同的优势， 就是处理速度快（高性能）。

那Redis为什么快呢？

## 基于内存实现

内存读写速度是比磁盘读写快很多倍的。
- Redis是基于内存存储实现的数据库，相对于数据存在磁盘的数据库，就省去磁盘磁盘I/O的消耗。
- MySQL等磁盘数据库，需要建立索引来加快查询效率，而Redis数据存放在内存，直接操作内存，所以就很快。

![在这里插入图片描述](https://img-blog.csdnimg.cn/db1e5f90f2124eadbd4f959d80121dd3.png)
## 高效的数据结构
![在这里插入图片描述](https://img-blog.csdnimg.cn/61741fdcf7a44569953e1a42c7b5f70a.png)
#### 动态字符串
```c
struct sdshdr { //SDS简单动态字符串
    int len;    //记录buf中已使用的空间
    int free;   // buf中空闲空间长度
    char buf[]; //存储的实际内容
}
```
#### 字符串长度存储
- 在C语言中，要获取一个字符串的长度，需要从头开始遍历，复杂度为O（n）;
- 在Redis中，使用一个len字段记录当前字符串的长度，直接获取即可，时间复杂度为O(1)。
#### 减少内存重新分配的次数
- 在C语言中，修改一个字符串，需要重新分配内存，修改越频繁，内存分配就越频繁，而分配内存是会消耗性能的。
- 在Redis中，SDS提供了两种优化策略：空间预分配和惰性空间释放。
#### 空间预分配
当SDS简单动态字符串修改和空间扩充时，除了分配必需的内存空间，还会额外分配未使用的空间。

- SDS修改后，len的长度小于1M，那么将额外分配与len相同长度的未使用空间。比如len=100，重新分配后，buf 的实际长度会变为100(已使用空间)+100(额外空间)+1(空字符)=201。
- SDS修改后, len长度大于1M，那么程序将分配1M的未使用空间。
#### 惰性空间释放

当SDS缩短时，不是回收多余的内存空间，而是用free记录下多余的空间。后续再有修改操作，直接使用free中的空间，减少内存分配。

#### 哈希
Redis 作为一个KV的内存数据库，它使用用一张全局的哈希表来保存所有的键值对。
- 这张哈希表，有多个哈希桶组成，哈希桶中的entry元素保存了*key和*value指针，
- 其中*key指向了实际的键，*value指向了实际的值。
#### 跳跃表
![在这里插入图片描述](https://img-blog.csdnimg.cn/41f2f42656bc493e82dcd4a589835823.png)

跳跃表是Redis特有的数据结构，它其实就是在链表的基础上，增加多级索引，以提高查找效率。
- 每一层都有一条有序的链表，最底层的链表包含了所有的元素；
- 跳跃表支持平均 O（logN）,最坏 O（N）复杂度的节点查找；
- 还可以通过顺序性操作批量处理节点。

#### 压缩列表ziplist
压缩列表ziplist是列表键和字典键的的底层实现之一。它是由一系列特殊编码的内存块构成的列表， 一个ziplist可以包含多个entry， 每个entry可以保存一个长度受限的字符数组或者整数，
![在这里插入图片描述](https://img-blog.csdnimg.cn/27e40c9a123c442daa081a2db3d4ae69.png)


- zlbytes ：记录整个压缩列表占用的内存字节数
- zltail: 尾节点至起始节点的偏移量
- zllen : 记录整个压缩列表包含的节点数量
- entryX: 压缩列表包含的各个节点
- zlend : 特殊值，用于标记压缩列表末端


## 合理的数据编码
Redis支持多种数据基本类型，每种基本类型对应不同的数据结构，每种数据结构对应不一样的编码。为了提高性能，Redis使用数据结构最适合的编码搭配。

Redis是使用对象（redisObject）来表示数据库中的键值，当我们在 Redis 中创建一个键值对时，内存中创建两个对象
- 一个对象是用做键值对的键对象
- 另一个是键值对的值对象。

```c
typedef struct redisObject{
    //类型
   unsigned type:4;
   //编码
   unsigned encoding:4;
   //指向底层数据结构的指针
   void *ptr;
    //其他
 }robj;
```

redisObject中，type 对应的是对象类型，包含
- String
- List
- Hash
- Set
- zset

encoding 对应的是编码

- String：如果存储数字的话，是用int类型的编码;如果存储非数字，小于等于39字节的字符串，是embstr；大于39个字节，则是raw编码。
- List：如果列表的元素个数小于512个，列表每个元素的值都小于64字节（默认），使用ziplist编码，否则使用linkedlist编码
- Hash：哈希类型元素个数小于512个，所有值小于64字节的话，使用ziplist编码,否则使用hashtable编码。
- Set：如果集合中的元素都是整数且元素个数小于512个，使用intset编码，否则使用hashtable编码。
- Zset：当有序集合的元素个数小于128个，每个元素的值小于64字节时，使用ziplist编码，否则使用skiplist（跳跃表）编码


## 合理的线程模型
#### 单线程模型
Redis是单线程的，是指Redis的网络IO和键值对读写是由一个线程来完成的。
但Redis的其他功能，比如持久化、异步删除、集群数据同步等等，实际是由额外的线程执行的。
- Redis的单线程模型，避免了CPU不必要的上下文切换和竞争锁的消耗。
- 因为是单线程，如果某个命令执行过长（如hgetall命令），会造成阻塞。
- Redis是面向快速执行场景的内存数据库

#### I/O 多路复用

IO多路复其实就是一种同步IO模型，它实现了一个线程可以监视多个文件句柄；
- 一旦某个文件句柄就绪，就能够通知应用程序进行相应的读写操作；
- 没有文件句柄就绪时,就会阻塞应用程序，交出cpu。

多路I/O复用技术可以让单个线程高效的处理多个连接请求，而Redis使用用epoll作为I/O多路复用技术的实现。并且Redis自身的事件处理模型将epoll中的连接、读写、关闭都转换为事件，不在网络I/O上浪费过多的时间。
![在这里插入图片描述](https://img-blog.csdnimg.cn/2452094bab174e888b76415e9bc4bac3.png)
## 虚拟内存机制
Redis构建了自己的VM机制 ，不会调用系统函数处理，会浪费一定的时间去移动和请求。

#### 虚拟内存机制
- 虚拟内存机制就是暂时把不经常访问的数据(冷数据)从内存交换到磁盘中，从而腾出宝贵的内存空间用于其它需要访问的数据(热数据)。
- 通过VM功能可以实现冷热数据分离，使热数据仍在内存中、冷数据保存到磁盘。这样就可以避免因为内存不足而造成访问速度下降的问题。



