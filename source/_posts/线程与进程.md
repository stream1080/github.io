---
title: 线程与进程
top: false
cover: false
toc: true
mathjax: false
categories:
  - 计算机基础
tags:
  - 线程
  - 进程
abbrlink: 52642
date: 2021-07-17 20:49:38
author:
img:
coverImg:
password:
summary:
---


## 进程
- 是指计算机中已运行的程序，它是一个动态执行的过程。假设我们电脑上同时运行了浏览器、QQ 以及代码编辑器三个软件，这三个软件之所以同时运行，就是进程所起的作用。
![在这里插入图片描述](https://img-blog.csdnimg.cn/20210717164449702.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Vwc3RyZWFtNDgw,size_16,color_FFFFFF,t_70)
## 线程
- 是操作系统能够进行运算调度的最小单位。大部分情况下，它被包含在进程之中，是进程中的实际运作单位。也就是说一个进程可以包含多个线程， 因此线程也被称为轻量级进程。
![在这里插入图片描述](https://img-blog.csdnimg.cn/20210717164530654.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Vwc3RyZWFtNDgw,size_16,color_FFFFFF,t_70)
## 线程的状态
线程从创建到最终的消亡，要经历若干个状态。一般来说，线程包括以下这几个状态：
- 创建(new)	新建状态，尚未启动的线程处于此状态；
- 就绪(runnable) 新建状态后，当前线程没有获得CPU时间片，等待CPU时间片轮转
- 运行(running) 可运行状态，Java 虚拟机中执行的线程处于此状态；
- 阻塞(blocked)  阻塞状态，等待监视器锁定而被阻塞的线程处于此状态；
- 等待(waiting)等待状态，无限期等待另一线程执行特定操作的线程处于此状态；
- 定时等待(time waiting)定时等待状态，在指定等待时间内等待另一线程执行操作的线程处于此状态；
- 消亡（dead）结束状态，已退出的线程处于此状态。

## 使用多线程可能遇到的问题
- 并发编程的目的就是为了能提高程序的执行效率提高程序运行速度，但是并发编程并不总是能提高程序
运行速度的，而且并发编程可能会遇到很多问题，比如:内存泄漏、上下文切换、死锁还有受限于硬件
和软件的资源闲置问题。


## 初始化线程
在Java中初始化线程有四种方法
- 继承 Thread 类，重写 run() 方法，该方法代表线程要执行的任务；
- 实现 Runnable 接口，实现 run() 方法，该方法代表线程要执行的任务；
- 实现 Callable 接口，实现 call() 方法，call() 方法作为线程的执行体，具有返回值，并且可以对异常进行声明和抛出。
-  使用线程池
### 继承Thread类
Thread 类是一个线程类，位于 java.lang 包下。用于创建线程

#### Thread 类的构造方法
- Thread()：创建一个线程对象；
- Thread(String name)：创建一个指定名称的线程对象；
- Thread(Runnable target)：创建一个基于 Runnable 接口实现类的线程对象；
- Thread(Runnable target, String name)：创建一个基于 Runnable 接口实现类，并具有指定名称的线程对象。
#### Thread 类的常用方法
- void run()：线程相关的代码写在该方法中，一般需要重写；
- void start()：启动当前线程；
- static void sleep(long m)：使当前线程休眠 m 毫秒；
- void join()：优先执行调用 join() 方法的线程。

run() 方法是一个非常重要的方法，它是用于编写线程执行体的方法

#### 继承Thread类创建线程
```java
	/**
     * 继承Thread类
     */
    public static class Thread01 extends Thread{
        @Override
        public void run() {
            System.out.println("当前线程ID："+Thread.currentThread().getId());
            System.out.println("运行结果：" + Math.random());
        }
    }
```
main方法创建一个线程
```java
public static void main(String[] args) {
        System.out.println("线程-开始");
        Thread01 thread01 = new Thread01();
        new Thread(thread01).start();
        System.out.println("线程-结束");
    }
```
运行结果
![在这里插入图片描述](https://img-blog.csdnimg.cn/20210717163318105.png)


### 实现Runnable接口
#### 使用Runnable接口的原因
- Java 不支持多继承，所有的类都只允许继承一个父类，可以认为继承也是一种资源；
- 但可以实现多个接口。如果继承了 Thread 类就无法继承其它类，这不利于扩展；
- 继承 Thread 类通常只重写 run() 方法，其他方法一般不会重写；
- 继承整个 Thread 类成本过高，开销过大。实现Runnable接口更轻量；

#### 实现Runnable接口创建线程

```java
    /**
     * 实现Runnable接口
     */
    public static class Runnable01 implements Runnable{
        @Override
        public void run() {
            System.out.println("当前线程ID："+Thread.currentThread().getId());
            System.out.println("运行结果：" + Math.random()*10000);
        }
    }
```
main方法创建一个线程

```java
    public static void main(String[] args) {
        System.out.println("线程-开始");
        Runnable01 runnable01 = new Runnable01();
        new Thread(runnable01).start();
        System.out.println("线程-结束");
    }
```
运行结果
![在这里插入图片描述](https://img-blog.csdnimg.cn/20210717164001866.png)

### 实现Callable接口 + FutureTask 接口
由于上述两种方式没有返回结果，JDK1.5后加入了Callable接口 + FutureTask 接口
#### 使用Callable接口和FutureTask接口的原因
- 继承 Thread 类和实现 Runnable 接口这两种创建线程的方式都没有返回值。
- 线程执行完毕后，无法得到执行结果。
- 为了解决这个问题，Java 5 后，提供了 Callable 接口和 Future 接口；
- 通过Callable接口和FutureTask接口，可以在线程执行结束后，返回执行结果。

#### 实现Callable接口 + FutureTask接口创建线程 
```java
    /**
     * 实现Callable接口 + FutureTask (可以获取返回结果，处理异常)
     */
    public static class Callable01 implements Callable<Integer>{
        @Override
        public Integer call() throws Exception {
            System.out.println("当前线程ID："+Thread.currentThread().getId());
            System.out.println("运行结果：" + Math.random());
            int result = (int) Math.random();
            return result;
        }
    }
```
main方法创建一个线程

```java
    public static void main(String[] args) throws ExecutionException, InterruptedException {
        System.out.println("线程-开始");
        FutureTask futureTask = new FutureTask<>(new Callable01());
        new Thread(futureTask).start();
        //等待线程运行结束，获取返回值
        Integer integer = (Integer) futureTask.get();
        System.out.println("线程-结束"+integer);
    }
```
运行结果
![在这里插入图片描述](https://img-blog.csdnimg.cn/20210717164245946.png)
### 以上三种方式利弊分析
- 继承Thread类和实现Runnalbe接口方式创建线程，主进程无法获取线程的运算结果。有些需要返回结果的场景无法使用
- 实现Callable接口 + FutureTask :主进程可以获取线程的运算结果，但是不利于控制服务器中的线程资源。
- 如果大量的线程创建，可能导致服务器资源耗尽，所以我们需要使用线程池；


## 线程池
#### 为什么要用线程池
- 降低资源消耗。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。
- 提高响应速度。当任务到达时，任务可以不需要的等到线程创建就能立即执行。
- 提高线程的可管理性。线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系
统的稳定性，使用线程池可以进行统一的分配， 调优和监控。
- 通过线程池性能稳定，也可以获取执行结果，并捕获异常。
- 但是，在业务复杂情况下，一个异步调用可能会依赖于另一个异步调用的执行结果。

#### 创建线程池
《阿里巴巴Java开发手册》中强制线程池不允许使用Executors 去创建，而是通过ThreadPoolExecutor的方式，这样的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险

##### 方式一：Executors.newFixedThreadPool() 
使用ExecutorService 创建一个线程池
```java
    //保证当前系统中线程池是有限个，每个异步任务，提交给线程池让他自己去执行
    public static ExecutorService service = Executors.newFixedThreadPool(10);
```
将线程放入线程池中
```java
Thread01 thread01 = new Thread01();
service.execute(thread01);
```
运行结果
![在这里插入图片描述](https://img-blog.csdnimg.cn/20210717172736624.png)
##### 方式二：new ThreadPoolExecutor(）推荐
![在这里插入图片描述](https://img-blog.csdnimg.cn/20210717182532571.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Vwc3RyZWFtNDgw,size_16,color_FFFFFF,t_70)



