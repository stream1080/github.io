<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>select、poll和epoll的区别</title>
      <link href="/2021/11/07/select-poll-he-epoll-de-qu-bie/"/>
      <url>/2021/11/07/select-poll-he-epoll-de-qu-bie/</url>
      
        <content type="html"><![CDATA[<h2 id="进程所能打开的最大连接数"><a href="#进程所能打开的最大连接数" class="headerlink" title="进程所能打开的最大连接数"></a>进程所能打开的最大连接数</h2><h4 id="select"><a href="#select" class="headerlink" title="select"></a>select</h4><p>单个进程所能打开的最大连接数有FD_ SETSIZE宏定义， 其大小是32个整数的大小(在32位的机器上，大小就是32<em>32，同理64位机器上FD_ SETSIZE为32</em>64) </p><p>tips：我们可以对进行修改，然后重新编译内核，但是性能可能会受到影响，这需要进一步的测试。</p><h4 id="poll"><a href="#poll" class="headerlink" title="poll"></a>poll</h4><p>poll本质上和select没有区别，但是它没有最大连接数的限制，原因是它是基于链表来存储的</p><h4 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a>epoll</h4><p>虽然连接数有上限，但是很大，1G内存的机器上可以打开10万左右的连接，2G内存的机器可以打开20万左右的连接</p><h2 id="FD剧增后带来的IO效率问题"><a href="#FD剧增后带来的IO效率问题" class="headerlink" title="FD剧增后带来的IO效率问题"></a>FD剧增后带来的IO效率问题</h2><h4 id="select-1"><a href="#select-1" class="headerlink" title="select"></a>select</h4><p>因为每次调用时都会对连接进行线性遍历，所以随着FD的增加会造成遍历<br>速度慢的“线性下降性能问题”。</p><h4 id="poll-1"><a href="#poll-1" class="headerlink" title="poll"></a>poll</h4><p>由于poll与select的本质是一样的，所有poll有着和select一样的问题</p><h4 id="epoll-1"><a href="#epoll-1" class="headerlink" title="epoll"></a>epoll</h4><p>因为epoll内核中实现是根据每个fd上的callback函数来实现的，只有活跃的socket才会主动调用calback,所以在活跃socket较少的情况下，使用epoll没有前面两者的线性下降的性能问题，但是所有socket都很活跃的情况下，可能会有性能问题。</p><h2 id="消息传递方式"><a href="#消息传递方式" class="headerlink" title="消息传递方式"></a>消息传递方式</h2><h4 id="select-2"><a href="#select-2" class="headerlink" title="select"></a>select</h4><p>内核需要将消息传递到用户空间，都需要内核拷贝动作</p><h4 id="poll-2"><a href="#poll-2" class="headerlink" title="poll"></a>poll</h4><p>与select一样</p><h4 id="epoll-2"><a href="#epoll-2" class="headerlink" title="epoll"></a>epoll</h4><p>epoll通过内核和用户空间共享一块内存来 实现的</p><h2 id="select和epoll的区别。"><a href="#select和epoll的区别。" class="headerlink" title="select和epoll的区别。"></a>select和epoll的区别。</h2><p>select 函数监视的文件描述符分3类，分别是writefds、readfds、和exceptfds。调用后select函数会阻塞，直到有描述符就绪（有数据 可读、可写、或者有except），或者超时（timeout指定等待时间，如果立即返回设为null即可），函数返回。当select函数返回后，可以通过遍历fdset，来找到就绪的描述符。</p><p>select目前几乎在所有的平台上支持，其良好跨平台支持也是它的一个优点。select的一个缺点在于单个进程能够监视的文件描述符的数量存在最大限制，在Linux上一般为1024，可以通过修改宏定义甚至重新编译内核的方式提升这一限制，但是这样也会造成效率的降低。</p><p>内核需要传递消息到用户空间，需要内存拷贝</p><p>相对于select和poll来说，epoll更加灵活，没有描述符限制。epoll使用一个文件描述符管理多个描述符，将用户关系的文件描述符的事件存放到内核的一个事件表中，这样在用户空间和内核空间的copy只需一次。</p><p>epoll能打开的FD的上限远大于1024（1G的内存上能监听约10万个端口）。</p><p>效率提升，不是轮询的方式，不会随着FD数目的增加效率下降。只有活跃可用的FD才会调用callback函数；即Epoll最大的优点就在于它只管你“活跃”的连接，而跟连接总数无关，因此在实际的网络环境中，Epoll的效率就会远远高于select和poll。</p><h2 id="epoll的两种模式"><a href="#epoll的两种模式" class="headerlink" title="epoll的两种模式"></a>epoll的两种模式</h2><p>epoll对文件描述符的操作有两种模式：</p><ul><li>LT（level trigger）默认模式</li><li>ET（edge trigger）</li></ul><h3 id="LT模式"><a href="#LT模式" class="headerlink" title="LT模式"></a>LT模式</h3><p>当epoll_wait检测到描述符事件发生并将此事件通知应用程序，应用程序可以不立即处理该事件。下次调用epoll_wait时，会再次响应应用程序并通知此事件。</p><p>LT(level triggered)是缺省的工作方式，并且同时支持block和no-block socket。<br>在这种做法中，内核告诉你一个文件描述符是否就绪了，然后你可以对这个就绪的fd进行IO操作。如果你不作任何操作，内核还是会继续通知你的。</p><h3 id="ET模式"><a href="#ET模式" class="headerlink" title="ET模式"></a>ET模式</h3><p>当epoll_wait检测到描述符事件发生并将此事件通知应用程序，应用程序必须立即处理该事件。如果不处理，下次调用epoll_wait时，不会再次响应应用程序并通知此事件。</p><p>ET(edge-triggered)是高速工作方式，只支持no-block socket。</p><p>在这种模式下，当描述符从未就绪变为就绪时，内核通过epoll告诉你然后它会假设你知道文件描述符已经就绪，并且不会再为那个文件描述符发送更多的就绪通知，直到你做了某些操作导致那个文件描述符不再为就绪状态了</p><ul><li>比如，你在发送，接收或者接收请求，或者发送接收的数据少于一定量时导致了一个EWOULDBLOCK 错误</li></ul><p>如果一直不对这个fd作IO操作(从而导致它再次变成未就绪)，内核不会发送更多的通知(only once)。</p><ul><li>ET模式在很大程度上减少了epoll事件被重复触发的次数，因此效率要比LT模式高。</li><li>epoll工作在ET模式的时候，必须使用非阻塞套接口，以避免由于一个文件句柄的阻塞读/阻塞写操作把处理多个文件描述符的任务饿死。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IO流 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IO多路复用</title>
      <link href="/2021/11/06/io-duo-lu-fu-yong/"/>
      <url>/2021/11/06/io-duo-lu-fu-yong/</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>IO多路复用是一种同步IO模型，实现一个线程可以监视多个文件句柄</p><ul><li>一旦某个文件句柄就绪，就能够通知应用程序进行相应的读写操作；</li><li>没有文件句柄就绪时会阻塞应用程序，交出cpu；</li><li>多路是指网络连接，复用指的是同一个线程。</li></ul><h2 id="三种实现方式"><a href="#三种实现方式" class="headerlink" title="三种实现方式"></a>三种实现方式</h2><h3 id="select"><a href="#select" class="headerlink" title="select"></a>select</h3><ul><li>时间复杂度O(n)，它仅仅知道了，有I/O事件发生了，却并不知道是哪那几个流（可能有一个，多个，甚至全部），</li><li>只能无差别轮询所有流，找出能读出数据，或者写入数据的流，对他们进行操作。</li><li>所以select具有O(n)的无差别轮询复杂度，同时处理的流越多，无差别轮询时间就越长。<h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">int</span> select <span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">,</span> fd_set <span class="token operator">*</span>readfds<span class="token punctuation">,</span> fd_set <span class="token operator">*</span>writefds<span class="token punctuation">,</span>             fd_set <span class="token operator">*</span>exceptfds<span class="token punctuation">,</span> struct timeval <span class="token operator">*</span>timeout<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li></ul><p>select 函数监视的文件描述符分3类，分别是writefds、readfds、和exceptfds。<br>调用后select函数会阻塞，直到有：</p><ul><li>描述符就绪（有数据可读、可写、或者有except）</li><li>超时（timeout指定等待时间，如果立即返回设为null即可）</li><li>函数返回。</li></ul><p>当select函数返回后，可以通过遍历fdset，来找到就绪的描述符。</p><h4 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h4><ul><li>良好的跨平台支持，select目前几乎在所有的平台上支持。</li><li>单个进程能够监视的文件描述符的数量存在最大限制，在Linux上一般为1024可以修改限制，但是这样也会造成效率的降低。</li></ul><h3 id="poll"><a href="#poll" class="headerlink" title="poll"></a>poll</h3><p>时间复杂度O(n)，poll本质上和select没有区别，它将用户传入的数组拷贝到内核空间，然后查询每个fd对应的设备状态， </p><ul><li>没有最大连接数的限制，原因是它是基于链表来存储的。</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">int</span> poll <span class="token punctuation">(</span>struct pollfd <span class="token operator">*</span>fds<span class="token punctuation">,</span> unsigned <span class="token keyword">int</span> nfds<span class="token punctuation">,</span> <span class="token keyword">int</span> timeout<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h4><p>poll使用一个 pollfd的指针实现。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">struct pollfd <span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> fd<span class="token punctuation">;</span>            <span class="token comment">/* file descriptor */</span>    <span class="token keyword">short</span> events<span class="token punctuation">;</span>      <span class="token comment">/* requested events to watch */</span>    <span class="token keyword">short</span> revents<span class="token punctuation">;</span>     <span class="token comment">/* returned events witnessed */</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="优缺点-1"><a href="#优缺点-1" class="headerlink" title="优缺点"></a>优缺点</h4><p>pollfd结构包含了要监视的event和发生的event，不再使用select“参数-值”传递的方式。</p><ul><li>pollfd并没有最大数量限制（但是数量过大后性能也是会下降）</li><li>和select函数一样，poll返回后，需要轮询pollfd来获取就绪的描述符。</li></ul><h3 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a>epoll</h3><p>时间复杂度O(1)，epoll可以理解为event poll，不同于忙轮询和无差别轮询，epoll会把哪个流发生了怎样的I/O事件通知我们。</p><ul><li>epoll实际上是事件驱动（每个事件关联上fd）的，此时对这些流的操作都是有意义的。</li></ul><h4 id="实现-2"><a href="#实现-2" class="headerlink" title="实现"></a>实现</h4><p>epoll操作过程需要三个接口，分别如下：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">int</span> <span class="token function">epoll_create</span><span class="token punctuation">(</span><span class="token keyword">int</span> size<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">epoll_ctl</span><span class="token punctuation">(</span><span class="token keyword">int</span> epfd<span class="token punctuation">,</span> <span class="token keyword">int</span> op<span class="token punctuation">,</span> <span class="token keyword">int</span> fd<span class="token punctuation">,</span> struct epoll_event <span class="token operator">*</span>event<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">epoll_wait</span><span class="token punctuation">(</span><span class="token keyword">int</span> epfd<span class="token punctuation">,</span> struct epoll_event <span class="token operator">*</span> events<span class="token punctuation">,</span>                <span class="token keyword">int</span> maxevents<span class="token punctuation">,</span> <span class="token keyword">int</span> timeout<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">int</span> <span class="token function">epoll_create</span><span class="token punctuation">(</span><span class="token keyword">int</span> size<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>创建一个epoll的句柄，size用来告诉内核这个监听的数目一共有多大，这个参数不同于select()中的第一个参数，给出最大监听的fd+1的值</li><li>参数size并不是限制了epoll所能监听的描述符最大个数，只是对内核初始分配内部数据结构的一个建议。</li><li>当创建好epoll句柄后，它就会占用一个fd值，在使用完epoll后，必须调用close()关闭，否则可能导致fd被耗尽。</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">int</span> <span class="token function">epoll_ctl</span><span class="token punctuation">(</span><span class="token keyword">int</span> epfd<span class="token punctuation">,</span> <span class="token keyword">int</span> op<span class="token punctuation">,</span> <span class="token keyword">int</span> fd<span class="token punctuation">,</span> struct epoll_event <span class="token operator">*</span>event<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>函数是对指定描述符fd执行op操作。</p><ul><li>epfd：是epoll_create()的返回值。</li><li>op：表示op操作，用三个宏来表示，分别添加、删除和修改对fd的监听事件。<ul><li>添加EPOLL_CTL_ADD，</li><li>删除EPOLL_CTL_DEL，</li><li>修改EPOLL_CTL_MOD。</li></ul></li><li>fd：是需要监听的fd（文件描述符）</li><li>epoll_event：是告诉内核需要监听什么事，</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">int</span> <span class="token function">epoll_wait</span><span class="token punctuation">(</span><span class="token keyword">int</span> epfd<span class="token punctuation">,</span> struct epoll_event <span class="token operator">*</span> events<span class="token punctuation">,</span>                <span class="token keyword">int</span> maxevents<span class="token punctuation">,</span> <span class="token keyword">int</span> timeout<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>等待epfd上的io事件，最多返回maxevents个事件。</p><ul><li>参数events用来从内核得到事件的集合</li><li>maxevents告之内核这个events有多大，这个maxevents的值不能大于创建epoll_create()时的size，</li><li>参数timeout是超时时间（毫秒，0会立即返回，-1将不确定，也有说法说是永久阻塞）。该函数返回需要处理的事件数目，如返回0表示已超时。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IO流 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>分布式事务之两阶段提交</title>
      <link href="/2021/11/03/fen-bu-shi-shi-wu-zhi-liang-jie-duan-ti-jiao/"/>
      <url>/2021/11/03/fen-bu-shi-shi-wu-zhi-liang-jie-duan-ti-jiao/</url>
      
        <content type="html"><![CDATA[<h2 id="两阶段提交协议"><a href="#两阶段提交协议" class="headerlink" title="两阶段提交协议"></a>两阶段提交协议</h2><ul><li>两阶段提交协议把分布式事务分为两个阶段，一个是准备阶段，另一个是提交阶段；</li><li>准备阶段和提交阶段都是由事务管理器发起的；</li><li>我们可以将事务管理器称为协调者，将资源管理器称为参与者。</li></ul><h2 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h2><h4 id="准备阶段："><a href="#准备阶段：" class="headerlink" title="准备阶段："></a>准备阶段：</h4><p>协调者向参与者发起指令，参与者评估自己的状态，如果参与者评估指令可以完成，则会写redo或者undo日志（Write-Ahead Log的一种），然后锁定资源，执行操作，但是并不提交。<br><img src="https://img-blog.csdnimg.cn/7f5ba60ae0344ac6af22a614986d0f71.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5LiA5rGf5rqq5rC0,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><h4 id="提交阶段："><a href="#提交阶段：" class="headerlink" title="提交阶段："></a>提交阶段：</h4><ul><li>如果每个参与者明确返回准备成功，也就是预留资源和执行操作成功，则协调者向参与者发起提交指令，参与者提交资源变更的事务，释放锁定的资源；</li><li>如果任何一个参与者明确返回准备失败，也就是预留资源或者执行操作失败，则协调者向参与者发起中止指令，参与者取消已经变更的事务，执行undo日志，释放锁定的资源。<img src="https://img-blog.csdnimg.cn/c4705696bb2f461aa55698bbd4fc8b19.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5LiA5rGf5rqq5rC0,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></li></ul><h2 id="存在问题"><a href="#存在问题" class="headerlink" title="存在问题"></a>存在问题</h2><p>两阶段提交协议在准备阶段锁定资源，这是一个非常损耗资源的操作，能保证强一致性，但是实现起来复杂、成本较高、不够灵活，更重要的是它有一些致命的问题</p><h4 id="阻塞："><a href="#阻塞：" class="headerlink" title="阻塞："></a>阻塞：</h4><p>从上面的描述来看，对于任何一次指令都必须收到明确的响应，才会继续进行下一步，否则处于阻塞状态，占用的资源被一直锁定，不会被释放。</p><h4 id="单点故障："><a href="#单点故障：" class="headerlink" title="单点故障："></a>单点故障：</h4><p>如果协调者宕机，参与者没有协调者指挥，则会一直阻塞，尽管可以通过选举新的协调者替代原有协调者，但是如果协调者在发送一个提交指令后宕机，而提交指令仅仅被一个参与者接收，并且参与者接收后也宕机，则新上任的协调者无法处理这种情况。</p><h4 id="脑裂："><a href="#脑裂：" class="headerlink" title="脑裂："></a>脑裂：</h4><p>协调者发送提交指令，有的参与者接收到并执行了事务，有的参与者没有接收到事务就没有执行事务，多个参与者之间是不一致的。</p><h4 id="数据状态不确定"><a href="#数据状态不确定" class="headerlink" title="数据状态不确定"></a>数据状态不确定</h4><p>协调者再发出commit消息之后宕机，而唯一接收到这条消息的参与者同时也宕机了。那么即使协调者通过选举协议产生了新的协调者，这条事务的状态也是不确定的，没人知道事务是否被已经提交。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>上面的问题发生的概论比较小，但都需要人工干预处理，没有自动化的解决方案，因此两阶段提交协议在正常情况下能保证系统的强一致性，但是在出现异常的情况下，当前处理的操作处于错误状态，需要人工干预解决，因此可用性不够好。</p>]]></content>
      
      
      <categories>
          
          <category> 分布式微服务 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分布式事务 </tag>
            
            <tag> 数据一致性 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>分布式事务之三阶段提交</title>
      <link href="/2021/11/02/fen-bu-shi-shi-wu-zhi-san-jie-duan-ti-jiao/"/>
      <url>/2021/11/02/fen-bu-shi-shi-wu-zhi-san-jie-duan-ti-jiao/</url>
      
        <content type="html"><![CDATA[<p>三阶段提交协议是两阶段提交协议的改进版本，它通过超时机制解决了阻塞的问题，并且把两个阶段增加为三个阶段。</p><h2 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h2><h4 id="询问阶段"><a href="#询问阶段" class="headerlink" title="询问阶段"></a>询问阶段</h4><p>协调者询问参与者是否可以完成指令，协调者只需要回答是或不是，而不需要做真正的操作，这个阶段超时会导致中止。<br><img src="https://img-blog.csdnimg.cn/94897bae453343b6ac1c56b83a55d314.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5LiA5rGf5rqq5rC0,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><h4 id="准备阶段"><a href="#准备阶段" class="headerlink" title="准备阶段"></a>准备阶段</h4><ul><li>如果在询问阶段所有参与者都返回可以执行操作，则协调者向参与者发送预执行请求，然后参与者写redo和undo日志，执行操作但是不提交操作；</li><li>如果在询问阶段任意参与者返回不能执行操作的结果，则协调者向参与者发送中止请求，这里的逻辑与两阶段提交协议的准备阶段是相似的。<br><img src="https://img-blog.csdnimg.cn/b04e26303c904cb9b78826d5b597b186.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5LiA5rGf5rqq5rC0,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></li></ul><h4 id="提交阶段"><a href="#提交阶段" class="headerlink" title="提交阶段"></a>提交阶段</h4><ul><li><p>如果每个参与者在准备阶段返回准备成功，也就是说预留资源和执行操作成功，则协调者向参与者发起提交指令，参与者提交资源变更的事务，释放锁定的资源；</p></li><li><p>如果任何参与者返回准备失败，也就是说预留资源或者执行操作失败，则协调者向参与者发起中止指令，参与者取消已经变更的事务，执行 undo 日志，释放锁定的资源，这里的逻辑与两阶段提交协议的提交阶段一致。<br><img src="https://img-blog.csdnimg.cn/1cdb4a63102844b5aa07b1aec7ca680d.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5LiA5rGf5rqq5rC0,size_20,color_FFFFFF,t_70,g_se,x_16" alt="三阶段提交协议的成功场景示意图如下图所示："></p><h2 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h2></li><li><p>增加了一个询问阶段，询问阶段可以确保尽可能早地发现无法执行操作而需要中止的行为，但是它并不能发现所有这种行为，只会减少这种情况的发生。</p></li><li><p>在准备阶段以后，协调者和参与者执行的任务中都增加了超时，一旦超时，则协调者和参与者都会继续提交事务，默认为成功，这也是根据概率统计超时后默认为成功的正确性最大。</p></li><li><p>三阶段提交协议与两阶段提交协议相比，具有如上优点，但是一旦发生超时，系统仍然会发生不一致，只不过这种情况很少见，好处是至少不会阻塞和永远锁定资源。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 分布式微服务 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分布式事务 </tag>
            
            <tag> 数据一致性 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RabbitMQ 如何保证消息不会被重复消费</title>
      <link href="/2021/10/30/rabbitmq-ru-he-bao-zheng-xiao-xi-bu-hui-bei-chong-fu-xiao-fei/"/>
      <url>/2021/10/30/rabbitmq-ru-he-bao-zheng-xiao-xi-bu-hui-bei-chong-fu-xiao-fei/</url>
      
        <content type="html"><![CDATA[<p>所有的消息队列都要保证同一条消息不会被重复消费</p><ul><li>举个例子：假设有个系统，消费一条往数据库里插入一条，要是你一个消息重复两次，你不就插入了两条，这数据就错了</li><li>所以消费到第二次的时候，自己判断一下已经消费过了，直接扔了，就保留了一条数据</li></ul><p>一条数据重复出现两次，数据库里就只有一条数据，这就保证了系统的幂等性幂等性。</p><ul><li>一个请求重复多次，需要确保对应的数据是不会改变的，不能出错。<h2 id="为什么会重复消费"><a href="#为什么会重复消费" class="headerlink" title="为什么会重复消费"></a>为什么会重复消费</h2>（1）生产者重复发送消息：生产者在往消息队列发送消息时，发生了网络抖动，生产者没有收到确认信号，但是实际上消息队列已经收到了消息，超过一定时间后生产者会重新发送消息，这时一条消息被发送了两次；<br>（2）消费者重复接受消息：消费者成功消费消息后，发生了网络抖动，消息队列没有收到确认信号，超过一段时间后会重新给消费者投递相同的消息，同一条消息即存在被消费两次的可能。</li></ul><h2 id="如何解决"><a href="#如何解决" class="headerlink" title="如何解决"></a>如何解决</h2><p>通用解决方案是在消息实体中添加全局唯一的id，例如 msg_id（消息ID），在代码中保证消息的幂等性，</p><ul><li>消费者在收到消息之后，根据 msg_id 从缓存或者数据库中查询是否存在已有消息；</li><li>如果不存在已有消息，那么消费之后，将 msg_id 对应的消息实体或者序列化对象写入缓存或者数据库；</li><li>如果存在已有消息，说明这条消息已被消费过，丢弃消息并且打一条告警日志。</li></ul><p>并且可以根据重复消费的容忍程度以及性能要求选择使用缓存还是使用数据库，</p><ul><li>如果对判断的速度要求高，可以使用 Redis 作为缓存；</li><li>如果对判断的稳定性和鲁棒性要求高，使用数据库存储消息实体，同时将 msg_id 作为数据库表的唯一键，插入重复记录一定会抛出异常，避免数据库因为并发问题产生脏数据，保证了消息消费的不可重复性。</li></ul><h2 id="结合业务分析"><a href="#结合业务分析" class="headerlink" title="结合业务分析"></a>结合业务分析</h2><ul><li>如果是对数据库进行写库，先根据主键查一下，如果这数据都有了，就不写入</li><li>如果是写redis，那没问题了，反正每次都是set，天然幂等性。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 消息队列 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RabbitMQ </tag>
            
            <tag> 重复消费 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RabbitMQ如何保证消息顺序消费</title>
      <link href="/2021/10/29/rabbitmq-ru-he-bao-zheng-xiao-xi-shun-xu-xiao-fei/"/>
      <url>/2021/10/29/rabbitmq-ru-he-bao-zheng-xiao-xi-shun-xu-xiao-fei/</url>
      
        <content type="html"><![CDATA[<h2 id="为什么要顺序消费"><a href="#为什么要顺序消费" class="headerlink" title="为什么要顺序消费"></a>为什么要顺序消费</h2><p>保证消息的顺序消费是生产业务场景下经常面临的挑战，例如电商的下单逻辑，在用户下单之后，会发送创建订单和扣减库存的消息，我们需要保证扣减库存在创建订单之后执行。</p><ul><li>处理业务逻辑后，向MQ发送一条消息，再由消费者从 MQ 中获取 消息落盘到MySQL 中。</li><li>在这个过程中，可能会有增删改的操作，比如执行顺序是增加、修改、删除。</li><li>消费者可能换了顺序给执行成删除、修改、增加，所以我们要保证消息的顺序消费</li></ul><h2 id="为什么会不按顺序消费"><a href="#为什么会不按顺序消费" class="headerlink" title="为什么会不按顺序消费"></a>为什么会不按顺序消费</h2><p>对于 RabbitMQ 来说，导致上面顺序错乱的原因通常是消费者是集群部署，不同的消费者消费到了同一订单的不同的消息。</p><ul><li>如消费者1执行了增加，消费者2执行了修改，消费者C执行了删除</li><li>但是消费者C执行比消费者B快，消费者B又比消费者A快，就会导致消费消息的时候顺序错乱</li><li>本该顺序是增加、修改、删除，变成了删除、修改、增加.<br><img src="https://img-blog.csdnimg.cn/77a568c090d24eb68f041cd17126220b.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5LiA5rGf5rqq5rC0,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></li></ul><h2 id="如何解决"><a href="#如何解决" class="headerlink" title="如何解决"></a>如何解决</h2><p>RabbitMQ 的问题是由于不同的消息都发送到了同一个 queue 中，多个消费者都消费同一个 queue 的消息。</p><ul><li>我们可以给 RabbitMQ 创建多个 queue，每个消费者固定消费一个 queue 的消息，</li><li>生产者发送消息的时候，同一个类型的消息发送到同一个 queue 中</li><li>由于同一个 queue 的消息是一定会保证有序的，那么同一个订单号的消息就只会被一个消费者顺序消费，从而保证了消息的顺序性。<br><img src="https://img-blog.csdnimg.cn/d8c2d643644646f9be78cf4884a828ff.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5LiA5rGf5rqq5rC0,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></li></ul>]]></content>
      
      
      <categories>
          
          <category> 消息队列 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RabbitMQ </tag>
            
            <tag> 顺序消费 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TCP的粘包和拆包</title>
      <link href="/2021/10/13/tcp-de-nian-bao-he-chai-bao/"/>
      <url>/2021/10/13/tcp-de-nian-bao-he-chai-bao/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是粘包和拆包"><a href="#什么是粘包和拆包" class="headerlink" title="什么是粘包和拆包"></a>什么是粘包和拆包</h2><p>一个完整的业务数据包可能会被TCP拆分成多个包进行发送，也有可能把多个小的包封装成一个大的数据包发送，这个就是TCP的拆包和粘包问题。</p><h4 id="第一种情况-正常"><a href="#第一种情况-正常" class="headerlink" title="第一种情况(正常)"></a>第一种情况(正常)</h4><p>接收端正常收到两个数据包，即没有发生拆包和粘包的现象；</p><p><img src="https://img-blog.csdnimg.cn/0dd185d80ed7419c99f241e13d97b33c.png" alt="在这里插入图片描述"></p><h4 id="第二种情况"><a href="#第二种情况" class="headerlink" title="第二种情况"></a>第二种情况</h4><p>接收端只收到一个数据包，由于TCP是不会出现丢包的，所以这一个数据包中包含了发送端发送的两个数据包的信息，这种现象即为粘包。</p><p>这种情况由于接收端不知道这两个数据包的界限，所以对于接收端来说很难处理。<br><img src="https://img-blog.csdnimg.cn/5b0e17395ab0423a8b2c275fcf8de9eb.png" alt="在这里插入图片描述"></p><h4 id="第三种情况"><a href="#第三种情况" class="headerlink" title="第三种情况"></a>第三种情况</h4><p>接收端收到了两个数据包，但是这两个数据包要么是不完整的，要么就是多出来一块，这种情况即发生了拆包和粘包。<br><img src="https://img-blog.csdnimg.cn/2ebf028e7f7a404490314f5d6f41cd86.png" alt="在这里插入图片描述"><br>这两种情况如果不加特殊处理，对于接收端同样是不好处理的<br><img src="https://img-blog.csdnimg.cn/0b1efe60580848bca400bf9e802a7fef.png" alt="在这里插入图片描述"></p><h2 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h2><ol><li><p>应用程序写入的数据大于套接字缓冲区大小，这将会发生拆包。</p></li><li><p>应用程序写入数据小于套接字缓冲区大小，网卡将应用多次写入的数据发送到网络上，这将会发生粘包。</p></li><li><p>进行MSS（最大报文长度）大小的TCP分段，当TCP报文长度-TCP头部长度&gt;MSS的时候将发生拆包。</p></li><li><p>接收方法不及时读取套接字缓冲区数据，这将发生粘包。</p></li></ol><h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><ol><li><p>发送端给每个数据包添加包首部，首部中应该至少包含数据包的长度，这样接收端在接收到数据后，通过读取包首部的长度字段，便知道每一个数据包的实际长度了。</p></li><li><p>发送端将每个数据包封装为固定长度（不够的可以通过补0填充），这样接收端每次从接收缓冲区中读取固定长度的数据就自然而然的把每个数据包拆分开来。</p></li><li><p>可以在数据包之间设置边界，如添加特殊符号，这样，接收端通过这个边界就可以将不同的数据包拆分开。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TCP/IP </tag>
            
            <tag> 粘包拆包 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于RedLock的分布式锁</title>
      <link href="/2021/10/12/ji-yu-redlock-de-fen-bu-shi-suo/"/>
      <url>/2021/10/12/ji-yu-redlock-de-fen-bu-shi-suo/</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>在单个主节点的架构上实现分布式锁，是无法保证高可用的，在生产环境上，我们的Redis都是以集群部署的；</p><p>那么如果Redis实现分布式锁的是一个主从集群，可能会发生什么情况呢？<br><img src="https://img-blog.csdnimg.cn/df7cdf3ffafb4a0aab070ad0ab176867.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5LiA5rGf5rqq5rC0,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><ul><li>如果进程A在主节点上加锁成功，然后这个主节点宕机了，则从节点将会晋升为主节点。</li><li>若此时进程B在新的主节点上加锁成功，之后原主节点重启，成为了从节点，系统中将同时出现两把锁，这是违背锁的唯一性原则的。</li></ul><h2 id="RedLock实现"><a href="#RedLock实现" class="headerlink" title="RedLock实现"></a>RedLock实现</h2><p>如果要保证分布式锁的高可用，则需要采用多个节点的实现方案。</p><p>Redis的官方给出的建议是采用RedLock算法的实现方案。该算法基于多个Redis节点</p><h4 id="基本流程"><a href="#基本流程" class="headerlink" title="基本流程"></a>基本流程</h4><ul><li>集群中的节点相互独立，不存在主从复制或者集群协调机制；</li><li>加锁：以相同的KEY向N个实例加锁，只要超过一半节点成功，则认定加锁成功；</li><li>解锁：向所有的实例发送DEL命令，进行解锁；<br><img src="https://img-blog.csdnimg.cn/6f1b548a5a5549dd8bc90cfff64a715b.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5LiA5rGf5rqq5rC0,size_16,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><h4 id="算法流程"><a href="#算法流程" class="headerlink" title="算法流程"></a>算法流程</h4></li></ul><ol><li><p>获取当前时间戳</p></li><li><p>client尝试按照顺序使用相同的key,value获取所有redis服务的锁，在获取锁的过程中的获取时间比锁过期时间短很多，这是为了不要过长时间等待已经关闭的redis服务。并且试着获取下一个redis实例。比如：TTL为5s,设置获取锁最多用1s，所以如果一秒内无法获取锁，就放弃获取这个锁，从而尝试获取下个锁</p></li><li><p>client通过获取所有能获取的锁后的时间减去第一步的时间，这个时间差要小于TTL时间并且至少有超过一半的redis实例成功获取锁，才算真正的获取锁成功</p></li><li><p>如果成功获取锁，则锁的真正有效时间是 TTL减去第三步的时间差 的时间；比如：TTL 是5s,获取所有锁用了2s,则真正锁有效时间为3s(其实应该再减去时钟漂移);</p></li><li><p>如果客户端由于某些原因获取锁失败，便会开始解锁所有redis实例；因为可能已经获取了小于一半的redis实例的锁，必须释放，否则影响其他client获取锁</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 缓存 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
            <tag> 分布式锁 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis实现分布式锁</title>
      <link href="/2021/10/10/redis-shi-xian-fen-bu-shi-suo/"/>
      <url>/2021/10/10/redis-shi-xian-fen-bu-shi-suo/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是分布式锁"><a href="#什么是分布式锁" class="headerlink" title="什么是分布式锁"></a>什么是分布式锁</h2><p>分布式锁其实可以理解为:控制分布式系统有序的去对共享资源进行操作,通过互斥来保持一致性</p><h2 id="为什么要分布式锁"><a href="#为什么要分布式锁" class="headerlink" title="为什么要分布式锁"></a>为什么要分布式锁</h2><p>当多个线程需要并发修改一个数据时，为了避免竞争，在单机的情况下，加synchronized或者Lock即可实现互斥</p><p>但在分布式的环境下，当多个server并发修改同一个资源时，为了避免竞争就需要使用分布式锁。</p><p>那为什么不能使用Java自带的锁（synchronized或者Lock）呢？</p><ul><li>因为Java中的锁是面向多线程设计的，它只局限于当前的实例。</li><li>而多个server实际上是多进程，是不同的实例，所以Java自带的锁机制在这个场景下是无效的。</li></ul><h2 id="如何实现分布式锁"><a href="#如何实现分布式锁" class="headerlink" title="如何实现分布式锁"></a>如何实现分布式锁</h2><p>采用Redis实现分布式锁，就是在Redis里存一份代表锁的数据，通常用随机字符串即可。</p><h3 id="加锁："><a href="#加锁：" class="headerlink" title="加锁："></a>加锁：</h3><h4 id="第一种方式"><a href="#第一种方式" class="headerlink" title="第一种方式"></a>第一种方式</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java">setnx key value<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这种方式的缺点是容易产生死锁，因为客户端有可能忘记解锁，或者解锁失败。</p><h4 id="第二种方式"><a href="#第二种方式" class="headerlink" title="第二种方式"></a>第二种方式</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java">setnx key valueexpire key seconds<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>给锁增加了过期时间，避免出现死锁。但这两个命令不是原子的，第二步可能会失败，依然无法避免死锁问题。</p><h4 id="第三种方式"><a href="#第三种方式" class="headerlink" title="第三种方式"></a>第三种方式</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java">set key value nx ex seconds <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>通过“set…nx…”命令，将加锁、过期命令编排到一起，它们是原子操作了，可以避免死锁。</p><h3 id="解锁："><a href="#解锁：" class="headerlink" title="解锁："></a>解锁：</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java">del key<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>解锁就是删除代表锁的那份数据，直接删除redis上面的数据。</p><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>上述方法看起来没有问题，但实际是有隐患的<br><img src="https://img-blog.csdnimg.cn/4678bef1efc04094b02729431c2069d8.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5LiA5rGf5rqq5rC0,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><ol><li>进程A在任务没有执行完毕时，锁已经到期被释放了。</li><li>等进程A的任务执行结束后，A会尝试释放锁，但是，它的锁已经过期不存在了，它此时释放的可能是其他线程的锁，比如B进程；</li><li>红框时间内，两个进程同时操作数据，极有可能出现线程安全的问题；</li></ol><h3 id="如何解决"><a href="#如何解决" class="headerlink" title="如何解决"></a>如何解决</h3><p>在加锁时就要给锁设置一个标识，加锁进程要记住这个标识。</p><ul><li>当进程解锁的时候，进行判断，是自己持有的锁才能释放</li><li>否则无法释放。可以为key设置一个随机字符串，来充当进程的标识。</li></ul><p>但是解锁的时候，判断、释放，这两步需要保证原子性，否则第二步失败的话，就会出现死锁，但判断和删除命令不是原子的。</p><p>在Redis中可以使用Lua脚本，通过Lua脚本将两个命令编排在一起，而整个Lua脚本的执行是原子的。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"># 加锁set key random<span class="token operator">-</span>value nx ex seconds # 解锁<span class="token keyword">if</span> redis<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token string">"get"</span><span class="token punctuation">,</span>KEYS<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">==</span> ARGV<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> then    <span class="token keyword">return</span> redis<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token string">"del"</span><span class="token punctuation">,</span>KEYS<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token keyword">else</span>    <span class="token keyword">return</span> <span class="token number">0</span>end<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 缓存 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
            <tag> 分布式锁 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL的执行计划(三)</title>
      <link href="/2021/10/07/mysql-de-zhi-xing-ji-hua-san/"/>
      <url>/2021/10/07/mysql-de-zhi-xing-ji-hua-san/</url>
      
        <content type="html"><![CDATA[<p>书接上回 <a href="https://blog.csdn.net/upstream480/article/details/120615700">MySQL的执行计划(二)</a></p><h2 id="执行计划中的列"><a href="#执行计划中的列" class="headerlink" title="执行计划中的列"></a>执行计划中的列</h2><h3 id="possible-keys"><a href="#possible-keys" class="headerlink" title="possible_keys"></a>possible_keys</h3><p>显示在查询中使用了哪些索引<br><img src="https://img-blog.csdnimg.cn/75296e9e4b8f420498f3a01f1015d330.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5LiA5rGf5rqq5rC0,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><h3 id="key"><a href="#key" class="headerlink" title="key"></a>key</h3><ul><li>实际使用的索引，如果为NULL，则没有使用索引；</li><li>查询中如果使用了覆盖索引，则该索引仅出现在key列中。<br><img src="https://img-blog.csdnimg.cn/bbf4082c4e8447c8b4ac51dab855ed62.png" alt="在这里插入图片描述"></li><li>possible_keys列表明哪一个索引有助于更高效的查询；</li><li>key是possible_keys的子集；</li><li>而key列表明实际优化采用了哪一个索引可以更加高效。</li></ul><h3 id="key-len"><a href="#key-len" class="headerlink" title="key_len"></a>key_len</h3><p>表示索引中使用的字节数，查询中使用的索的长度（最大可能长度），并非实际使用长度，理论上长度越短越好。</p><ul><li>key_len是根据表定义计算而得的，不是通过表内查询出来的</li><li>这个字段可以评估组合索引是否完全被使用，这也是我们优化sql时，评估索引的重要指标</li></ul><h3 id="ref"><a href="#ref" class="headerlink" title="ref"></a>ref</h3><ul><li>表示在key列记录的索引中查找值，所用的列或常量const。</li></ul><h3 id="rows"><a href="#rows" class="headerlink" title="rows"></a>rows</h3><p>估算出找到所需行而要读取的行数<br><img src="https://img-blog.csdnimg.cn/f6c9cad466c64e429d039525b18704dc.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5LiA5rGf5rqq5rC0,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>这个数字是内嵌循环关联计划里的循环数，它不是最终从表中读取出来的行数，而是MySQL为了找到符合查询的那些行而必须读取行的平均数，只能作为一个相对数来进行衡量。</p><ul><li>估算该sql返回结果集需要扫描读取的行数，这个值相关重要；</li><li>索引优化之后，扫描读取的行数越多，说明要么是索引设置不对，要么是字段传入的类型之类的问题，说明要优化空间越大</li></ul><h3 id="filtered"><a href="#filtered" class="headerlink" title="filtered"></a>filtered</h3><ul><li>返回结果的行数占读取行数的百分比，值越大越好；</li><li>百分比越高，说明需要查询到数据越准确；</li><li>百分比越小，说明查询到的数据量大，而结果集很少。</li></ul><h3 id="extra"><a href="#extra" class="headerlink" title="extra"></a>extra</h3><p>额外信息</p><p><strong>Using index</strong><br>表示SQL中使用了覆盖索引。<br><img src="https://img-blog.csdnimg.cn/e759b9b2122e427f9744249ce088b986.png" alt="在这里插入图片描述"></p><p><strong>Using where</strong><br>许多where条件里是涉及索引中的列，当它读取索引时，就能被存储引擎检验，因此不是所有带·where子句的查询都会显示“Using where”。<br><img src="https://img-blog.csdnimg.cn/4347858fe7c64a4da610448b50cdcfa8.png" alt="在这里插入图片描述"></p><p><strong>Using temporary</strong></p><ul><li>对查询结果排序时，使用了一个临时表，常见于order by 和group by<br><img src="https://img-blog.csdnimg.cn/0ba88e162d504c368a7be2cf126e2308.png" alt="在这里插入图片描述"></li></ul><p><strong>Using filesort</strong></p><ul><li>对数据使用了一个外部的索引排序，而不是按照表内的索引进行排序读取；</li><li>MySQL无法利用索引完成的排序操作成为“文件排序”。<br><img src="https://img-blog.csdnimg.cn/93c3a906083f4366af3623533e092f44.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5LiA5rGf5rqq5rC0,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
            <tag> 执行计划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis-有序集合的数据结构</title>
      <link href="/2021/10/06/redis-you-xu-ji-he-de-shu-ju-jie-gou/"/>
      <url>/2021/10/06/redis-you-xu-ji-he-de-shu-ju-jie-gou/</url>
      
        <content type="html"><![CDATA[<h2 id="集合概念"><a href="#集合概念" class="headerlink" title="集合概念"></a>集合概念</h2><h3 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h3><p>Set类似于Java中的HashSet 。Redis中的set类型是一种无序集合，集合中的元<br>素没有先后顺序，并且不可重复。</p><p>当需要存储一个列表数据，又不不能出现重复数据时，Set 是一个很好的选择，并且set提供了判断某个成员是否在一个Set集合内的接口，List是没有这种接口的</p><p>可以基于set轻易实现交集、并集、差集的操作。Redis 可以非常方便的实现如共同关注、共同粉丝、共同喜好等功能。这个过程也就是求交集的过程。</p><h3 id="Zset"><a href="#Zset" class="headerlink" title="Zset"></a>Zset</h3><p>和Set相比，sorted set增加了一个权重参数score, 使得集合中的元素能够按score<br>进行有序排列，还可以通过score的范围来获取元素的列表。有点像是Java中HashMap和TreeSet的结合体。</p><p>其有两种实现方式，分别是ziplist和skiplist</p><h2 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h2><p>当有序集合保存的元素数量小于128个或者有序集合保存的所有元素的长度小于64字节时，Zset选用ziplist实现，其他情况选用skiplist实现；</p><h3 id="ziplist-压缩列表"><a href="#ziplist-压缩列表" class="headerlink" title="ziplist - 压缩列表"></a>ziplist - 压缩列表</h3><p>ziplist，顾名思义压缩列表，每个集合元素使用两个紧挨在一起的压缩列表节点来保存，第一个节点保存元素的value，第二个元素保存元素的score；<br><img src="https://img-blog.csdnimg.cn/c4876263c60945998016ba6c5f3e7889.png" alt="在这里插入图片描述"></p><h3 id="skiplist-跳表"><a href="#skiplist-跳表" class="headerlink" title="skiplist - 跳表"></a>skiplist - 跳表</h3><p>跳表(skip List)是一种随机化的数据结构，基于并联的链表，实现简单，插入、删除、查找的复杂度均为logn。</p><p>简单说来跳表也是链表的一种，只不过它在链表的基础上增加了跳跃功能，正是这个跳跃的功能，使得在查找元素时，跳表能够提供logn的时间复杂度</p><p>普通链表<br><img src="https://img-blog.csdnimg.cn/92511fe8120b48a1af0a80a8a2c0f349.png" alt="在这里插入图片描述"></p><p>在普通链表中，如果我们要查找某个元素，那么需要从头开始逐个进行比较，直到找到包含数据的那个节点，或者找完所有的节点（没找到）。</p><ul><li>这样的话，时间复杂度为O(n)；</li><li>当我们要插入新数据的时候，也要经历同样的查找过程，从而确定插入位置</li></ul><p>跳表</p><p><img src="https://img-blog.csdnimg.cn/01ce37da07c940b6b717e644c524d5f4.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5LiA5rGf5rqq5rC0,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><p>假如我们每相邻两个节点增加一个指针，让指针指向下下个节点，如上图，比如节点是1 - 2 - 3 - 4 - 5，增加节点1 - 3 - 5</p><p>这样形成一个新的链表，但它包含的节点个数只有原来的一半1，3，5</p><ul><li>当我们想查找数据的时候，可以先沿着这个新链表进行查找。当碰到比待查数据大的节点时，再回到原来的链表中进行查找。</li><li>比如查找3，之间可用从1指向3，即可跳过2，当数据量大的时候，只需要查询原有数据量的一半</li></ul><p>利用同样的方式，我们可以在上层新产生的链表上，继续为每相邻的两个节点增加一个指针，从而产生第三层链表。<br><img src="https://img-blog.csdnimg.cn/9e80530dd5324377ae5aa097a26751a4.png" alt="在这里插入图片描述"><br>依次类推，当链表足够长的时候，这种多层链表的查找方式能让我们跳过很多下层节点，大大加快查找的速度。</p><p>skiplist正是受这种多层链表的想法的启发而设计出来的。实际上，按照上面生成链表的方式，上面每一层链表的节点个数，是下面一层的节点个数的一半，这样查找过程就非常类似于一个二分查找，使得查找的时间复杂度可以降低到O(log n)。</p><h3 id="存在问题"><a href="#存在问题" class="headerlink" title="存在问题"></a>存在问题</h3><p>这种数据结构可用加快查询速度，但是在插入删除数据是就会出现问题</p><ul><li>新插入一个节点之后，就会打乱上下相邻两层链表上节点个数严格的2:1的对应关系。</li><li>如果要维持这种对应关系，就必须把新插入的节点后面的所有节点（也包括新插入的节点）重新进行调整，这会让时间复杂度重新蜕化成O(n)。</li><li>删除数据也有同样的问题。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 缓存 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
            <tag> 有序集合 </tag>
            
            <tag> 跳表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL的执行计划(二)</title>
      <link href="/2021/10/06/mysql-de-zhi-xing-ji-hua-er/"/>
      <url>/2021/10/06/mysql-de-zhi-xing-ji-hua-er/</url>
      
        <content type="html"><![CDATA[<p>书接上回：<a href="https://blog.csdn.net/upstream480/article/details/120615005">MySQL执行计划(一)</a></p><h2 id="执行计划中的列"><a href="#执行计划中的列" class="headerlink" title="执行计划中的列"></a>执行计划中的列</h2><h3 id="type"><a href="#type" class="headerlink" title="type"></a>type</h3><p>type列指代访问类型，是MySQL决定如何查找表中的行。</p><p>是SQL查询优化中一个很重要的指标，拥有很多值，依次从最差到最优：</p><h4 id="ALL"><a href="#ALL" class="headerlink" title="ALL"></a>ALL</h4><p>全表扫描，性能最差，在写SQL时尽量避免此种情况的出现，也就是避免是</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://img-blog.csdnimg.cn/e83044a80d254d0fb5fc9357bb7e521c.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5LiA5rGf5rqq5rC0,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><h4 id="index"><a href="#index" class="headerlink" title="index"></a>index</h4><p>全索引查询，和全表查询的ALL类似，但是扫描表时按索引次序进行（遍历索引树），而不是按行扫描</p><p>index与ALL虽然都是读全表，但index是从索引中读取，而ALL是从硬盘读取。<br>显然，index性能上明显优于ALL，所有，合理的添加索引将有助于提升性能。</p><p>举例如下：<br><img src="https://img-blog.csdnimg.cn/2fabd07cdb3d4966b999143de1a18214.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5LiA5rGf5rqq5rC0,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><h4 id="range"><a href="#range" class="headerlink" title="range"></a>range</h4><p>只查询给定范围的行，使用一个索引来选择行。</p><ul><li>key列显示使用了那个索引；</li><li>一般就是在where语句中出现了bettween、&lt;、&gt;、in等的查询；</li><li>这种索引列上的范围扫描比全索引扫描index要好。<img src="https://img-blog.csdnimg.cn/623618fb584d447e96dd743f8d47c7ee.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5LiA5rGf5rqq5rC0,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><h4 id="ref"><a href="#ref" class="headerlink" title="ref"></a>ref</h4>非唯一性索引扫描，返回匹配某个单独值的所有行。本质是也是一种索引访问，它返回所有匹配某个单独值的行，然而它可能会找到多个符合条件的行，所以它属于查找和扫描的混合体。</li></ul><p>此类型只有当使用非唯一索引或者唯一索引的非唯一性前缀时，才会发生。<br><img src="https://img-blog.csdnimg.cn/0d76d82b62b14e6dbdb453d2a7e561c0.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5LiA5rGf5rqq5rC0,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><h4 id="eq-ref"><a href="#eq-ref" class="headerlink" title="eq_ref"></a>eq_ref</h4><ul><li>唯一索引扫描</li><li>主要用于主键或唯一索引扫描。</li></ul><h4 id="const"><a href="#const" class="headerlink" title="const"></a>const</h4><ul><li>通过索引一次就能找到，const用于比较primary key 或者unique索引。</li><li>因为只需匹配一行数据，所有很快。</li><li>将主键置于where列表中，mysql就能将该查询转换为一个const。<br><img src="https://img-blog.csdnimg.cn/accbeada941a4b16ada04d80985d3232.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5LiA5rGf5rqq5rC0,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></li></ul><h4 id="system"><a href="#system" class="headerlink" title="system"></a>system</h4><ul><li>表只有一行记录，这是const类型的特例，比较少见。</li></ul><p>下一篇<br><a href="https://blog.csdn.net/upstream480/article/details/120616953">MySQL执行计划(三)</a></p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
            <tag> 执行计划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL的执行计划(一)</title>
      <link href="/2021/10/05/mysql-de-zhi-xing-ji-hua-yi/"/>
      <url>/2021/10/05/mysql-de-zhi-xing-ji-hua-yi/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是执行计划"><a href="#什么是执行计划" class="headerlink" title="什么是执行计划"></a>什么是执行计划</h2><p>执行计划，就是一条SQL语句，在数据库中实际执行的时候，一步步的分别都做了什么事情</p><p>EXPLAIN命令是查看查询优化器是如何决定执行查询的主要方法，从它的查询结果中我们可以知道：</p><ul><li>一个SQL语句每一步是如何执行的；</li><li>都做了哪些事，分为哪几步；</li><li>有没有用到索引；</li><li>哪些字段用到了什么样的索引，是否有一些可优化的地方等。</li></ul><p>查看执行计划，只需在查询中的SELECT关键字之前增加EXPLAIN即可</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">语法：<span class="token keyword">EXPLAIN</span> <span class="token operator">+</span> <span class="token keyword">SELECT</span>查询语句示例：<span class="token keyword">EXPLAIN</span> <span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> <span class="token punctuation">`</span><span class="token keyword">user</span><span class="token punctuation">`</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>使用EXPLAIN时，会返回执行计划中每一步的信息，它会返回一行或多行信息，显示出执行计划中的每一部分和执行的次序。</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">EXPLAIN</span> <span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> <span class="token punctuation">`</span><span class="token keyword">user</span><span class="token punctuation">`</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://img-blog.csdnimg.cn/65163a07c98048638d4dfab62c0045a8.png" alt="在这里插入图片描述"></p><h2 id="执行计划中的列"><a href="#执行计划中的列" class="headerlink" title="执行计划中的列"></a>执行计划中的列</h2><p><img src="https://img-blog.csdnimg.cn/bb0128492f804b059e162e8af194fd0a.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5LiA5rGf5rqq5rC0,size_15,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><h3 id="Id"><a href="#Id" class="headerlink" title="Id"></a>Id</h3><p>id是一个编号，用于标识SELECT查询的序列号，表示执行SQL查询过程中SELECT子句或操作表的顺序。</p><ul><li>如果在SQL语句中没有子查询或关联查询，那么id列为1</li><li>否则，内层的SELECT语句一般会顺序编号；</li></ul><p>Id列可能会存在三种情况，以下一一列举：</p><h4 id="Id相同"><a href="#Id相同" class="headerlink" title="Id相同"></a>Id相同</h4><p>只有普通的查询，没有子查询，则Id相同为1</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">EXPLAIN</span> <span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> <span class="token punctuation">`</span><span class="token keyword">user</span><span class="token punctuation">`</span><span class="token punctuation">,</span><span class="token punctuation">`</span><span class="token keyword">comment</span><span class="token punctuation">`</span> <span class="token keyword">WHERE</span> <span class="token punctuation">`</span><span class="token keyword">comment</span><span class="token punctuation">`</span><span class="token punctuation">.</span>user_id <span class="token operator">=</span> <span class="token punctuation">`</span><span class="token keyword">user</span><span class="token punctuation">`</span><span class="token punctuation">.</span>id<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://img-blog.csdnimg.cn/057a89f6b571498fbefb5f821a4145a2.png" alt="在这里插入图片描述"></p><h4 id="Id不同"><a href="#Id不同" class="headerlink" title="Id不同"></a>Id不同</h4><p>存在子查询，id的序号会递增，id值越大优先级越高，越先被执行。</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">EXPLAIN</span> <span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> <span class="token punctuation">`</span><span class="token keyword">user</span><span class="token punctuation">`</span> <span class="token keyword">WHERE</span> id <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">SELECT</span> user_id <span class="token keyword">FROM</span> <span class="token punctuation">`</span><span class="token keyword">comment</span><span class="token punctuation">`</span> <span class="token keyword">WHERE</span> entity_type <span class="token operator">=</span> <span class="token number">2</span> <span class="token keyword">LIMIT</span> <span class="token number">1</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="https://img-blog.csdnimg.cn/310ff579697e43a497a2a7970fc28bb4.png" alt="在这里插入图片描述"></p><h4 id="Id相同和不同"><a href="#Id相同和不同" class="headerlink" title="Id相同和不同"></a>Id相同和不同</h4><p>id如果相同，认为是一组，从从上往下执行。<br>在所有组中，id值越大，优先级越高，越先执行。</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">EXPLAIN</span> <span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> <span class="token punctuation">`</span><span class="token keyword">user</span><span class="token punctuation">`</span> <span class="token keyword">WHERE</span> id <span class="token operator">IN</span> <span class="token punctuation">(</span><span class="token keyword">SELECT</span> user_id <span class="token keyword">FROM</span> <span class="token punctuation">`</span><span class="token keyword">comment</span><span class="token punctuation">`</span> <span class="token keyword">WHERE</span> entity_type <span class="token operator">=</span> <span class="token number">2</span> <span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="https://img-blog.csdnimg.cn/03a08fc0cd824c5181da896aabfb1815.png" alt="在这里插入图片描述"></p><h3 id="select-type列"><a href="#select-type列" class="headerlink" title="select_type列"></a>select_type列</h3><p>select_type列表示对应行的查询类型，是简单查询还是复杂查询</p><ul><li>主要用于区分普通查询、联合查询、子查询等复杂的查询。<br><img src="https://img-blog.csdnimg.cn/522f97c08a8d423a881a4973d547b41d.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5LiA5rGf5rqq5rC0,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><h3 id="table"><a href="#table" class="headerlink" title="table"></a>table</h3>table列表示对应行正在执行的哪张表，指代对应表名</li><li>如果SQL中定义了别名，则会显示该表的别名</li></ul><h3 id="partitions"><a href="#partitions" class="headerlink" title="partitions"></a>partitions</h3><ul><li>查询涉及到的分区。</li></ul><p>下一篇</p><p><a href="https://blog.csdn.net/upstream480/article/details/120615700">MySQL执行计划(二)</a></p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
            <tag> 执行计划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL的日志文件</title>
      <link href="/2021/10/04/mysql-de-ri-zhi-wen-jian/"/>
      <url>/2021/10/04/mysql-de-ri-zhi-wen-jian/</url>
      
        <content type="html"><![CDATA[<h2 id="二进制日志-binlog"><a href="#二进制日志-binlog" class="headerlink" title="二进制日志-binlog"></a>二进制日志-binlog</h2><p>二进制日志-binlog，它是 MySQL 重要的日志模块，在 Server 层实现</p><p>binlog 以二进制形式，将所有修改数据的 query 记录到日志文件中，包括：</p><ul><li>query 语句</li><li>执行时间</li><li>相关事务信息</li></ul><p>binlog 的开启，通过在配置文件 my.cnf 中，显式指定参数 log-bin=file_name</p><ul><li>statement记录的是SQL语句，最后会有COMMIT。</li><li>row记录的实际操作的数据记录，最后会有一个XID event。<h3 id="binlog的三种工作模式"><a href="#binlog的三种工作模式" class="headerlink" title="binlog的三种工作模式"></a>binlog的三种工作模式</h3><h4 id="Row-level："><a href="#Row-level：" class="headerlink" title="Row level："></a>Row level：</h4>日志中会记录每一行数据被修改的情况，然后在slave端对相同的数据进行修改。</li><li>优点：能清楚的记录每一行数据修改的细节</li><li>缺点：数据量太大<h4 id="Statement-level（默认）"><a href="#Statement-level（默认）" class="headerlink" title="Statement level（默认）"></a>Statement level（默认）</h4>每一条被修改数据的sql都会记录到master的bin-log中，slave在复制的时候sql进程会解析成和原来master端执行过的相同的sql再次执行。在主从同步中一般是不建议用statement模式的，因为会有些语句不支持，比如语句中包含UUID函数，以及LOAD DATA IN FILE语句等</li><li>优点：解决了 Row level下的缺点，不需要记录每一行的数据变化，减少bin-log日志量，节约磁盘IO，提高新能</li><li>缺点：容易出现主从复制不一致<h3 id="Mixed（混合模式）"><a href="#Mixed（混合模式）" class="headerlink" title="Mixed（混合模式）"></a>Mixed（混合模式）</h3>结合了Row level和Statement level的优点，但结构也更复杂。<h3 id="binlog的结构"><a href="#binlog的结构" class="headerlink" title="binlog的结构"></a>binlog的结构</h3></li><li><strong>timestamp</strong> 事件开始的执行时间，固定4字节展示是新纪元(epoch time)以来的秒数</li><li><strong>Event</strong> Type 指明该事件的类型</li><li><strong>server_ id</strong> 服务器的server ID</li><li><strong>Event size</strong> 该事件的长度</li><li><strong>Next_ log pos</strong> 固定4字节下一个event的开始位置</li><li><strong>Flag</strong>   固定2字节event flags</li><li><strong>Fixed part</strong> 每种Event Type对应结构体固定的结构部分</li><li><strong>Variable part</strong> 每种Event Type对应结构体可变的结构部分</li></ul><h2 id="重做日志-redo-log"><a href="#重做日志-redo-log" class="headerlink" title="重做日志-redo log"></a>重做日志-redo log</h2><p>redo log是存储引擎 InnoDB 生成的日志，主要为了保证数据的可靠性。redo log 记录了 InnoDB 所做的所有物理变更和事务信息。<br>由两部分组成：</p><ul><li>一是内存中的重做日志缓冲（redo log buffer），其是易失的；</li><li>二是重做日志文件（redo log file），它是持久的</li></ul><h2 id="binlog和redolog的区别"><a href="#binlog和redolog的区别" class="headerlink" title="binlog和redolog的区别"></a>binlog和redolog的区别</h2><ol><li>redolog是在InnoDB存储引擎层产生，而binlog是MySQL数据库的上层服务层产生的。</li><li>两种日志记录的内容形式不同。MySQL的binlog是逻辑日志，其记录是对应的SQL语句，对应的事务。而innodb存储引擎层面的重做日志是物理日志，是关于每个页（Page）的更改的物理情况。</li><li>两种日志与记录写入磁盘的时间点不同，binlog日志只在事务提交完成后进行一次写入。而innodb存储引擎的重做日志在事务进行中不断地被写入，并日志不是随事务提交的顺序进行写入的。</li><li>binlog不是循环使用，在写满或者重启之后，会生成新的binlog文件，redolog是循环使用。</li><li>binlog可以作为恢复数据使用，主从复制搭建，redolog作为异常宕机或者介质故障后的数据恢复使用。</li></ol><h2 id="回滚日志-undo-log"><a href="#回滚日志-undo-log" class="headerlink" title="回滚日志-undo log"></a>回滚日志-undo log</h2><p>重做日志记录了事务的行为，可以很好地通过其对页进行“重做”操作。<br>但是事务有时还需要进行回滚操作，这时就需要undo。因此在对数据库进行修改时，InnoDB存储引擎不但会产生redo，还会产生一定量的undo。这样如果用户执行的事务或语句由于某种原因失败了，又或者用户用一条ROLLBACK语句请求回滚，就可以利用这些undo信息将数据回滚到修改之前的样子。</p><p>redo存放在重做日志文件中，与redo不同，undo存放在数据库内部的一个特殊段（segment）中，这个段称为undo段（undo segment），undo段位于共享表空间内。</p><h2 id="错误日志-error-log"><a href="#错误日志-error-log" class="headerlink" title="错误日志-error log"></a>错误日志-error log</h2><p>错误日志，记录 MySQL 每次启动关闭的详细信息，以及运行过程中比较严重的警告和错误信息。</p><h2 id="慢查询日志-slow-query-log"><a href="#慢查询日志-slow-query-log" class="headerlink" title="慢查询日志-slow query log"></a>慢查询日志-slow query log</h2><p>慢查询日志，记录 MySQL 中执行时间较长的 query，包括执行时间、执行时长、执行用户、主机等信息。</p><p>慢查询日志默认是关闭的，可以通过配置 slow_query_log 进行开启。慢查询的阈值和存储路径，通过配置参数 long_query_time 和 slow_query_log_file 实现。</p><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml">slow_query_log = 1                              #开启慢查询long_query_time = 1                             #设置慢查询阈值为1sslow_query_log_file = /mysql/log/mysql-slow.log #设置慢查询日志存储路径<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
            <tag> 日志 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java的IO流</title>
      <link href="/2021/10/03/java-de-io-liu/"/>
      <url>/2021/10/03/java-de-io-liu/</url>
      
        <content type="html"><![CDATA[<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><h3 id="同步和异步"><a href="#同步和异步" class="headerlink" title="同步和异步"></a>同步和异步</h3><p>同步和异步是通信机制</p><ul><li><strong>同步</strong>：同步IO是用户线程发起IO请求后需要等待或轮询内核IO操作完成后才能继续执行。</li><li><strong>异步</strong>：异步IO是用户线程发起IO请求后可以继续执行，当内核IO操作完成后会通知用户线程，或调用用户线程注册的回调函数。</li></ul><h2 id="阻塞和非阻塞"><a href="#阻塞和非阻塞" class="headerlink" title="阻塞和非阻塞"></a>阻塞和非阻塞</h2><p>阻塞和非阻塞是调用状态</p><ul><li><strong>阻塞</strong>：阻塞IO是IO操作需要彻底完成后才能返回用户空间。</li><li><strong>非阻塞</strong>：非阻塞IO是IO操作调用后立即返回一个状态值，无需等IO操作彻底完成。</li></ul><h2 id="BIO"><a href="#BIO" class="headerlink" title="BIO"></a>BIO</h2><p>BIO是同步阻塞式IO，是JDK1.4 之前的IO模型。</p><ul><li>服务器实现模式为一个连接请求对应一个线程，服务器需要为每一个客户端请求创建一个线程，如果这个连接不做任何事会造成不必要的线程开销。</li><li>可以通过线程池改善，这种IO称为伪异步IO。适用连接数目少且服务器资源多的场景。</li></ul><h2 id="NIO"><a href="#NIO" class="headerlink" title="NIO"></a>NIO</h2><p>NIO是同步非阻塞IO，JDK1.4引入。服务器实现模式为多个连接请求对应一个线程，客户端连接请求会注册到一个多路复用器Selector，Selector 轮询到连接有IO请求时才启动一个线程处理。适用连接数目多且连接时间短的场景。</p><ul><li>同步是指线程还是要不断接收客户端连接并处理数据</li><li>非阻塞是指如果一个管道没有数据，不需要等待，可以轮询下一个管道。</li></ul><p>核心组件<br><img src="https://img-blog.csdnimg.cn/998e97c315244aa8a478105aac7f055b.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5LiA5rGf5rqq5rC0,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><h4 id="Selector"><a href="#Selector" class="headerlink" title="Selector"></a>Selector</h4><p>多路复用器，轮询检查多个Channel的状态，判断注册事件是否发生，即判断<br>Channel是否处于可读或可写状态。使用前需要将Channel注册到Selector，注册后会得到一个SelectionKey，通过SelectionKey获取Channel和Selector相关信息。</p><h4 id="Channel"><a href="#Channel" class="headerlink" title="Channel"></a>Channel</h4><p>双向通道，替换了BIO 中的Stream流，不能直接访问数据，要通过Buffer来读写数据，也可以和其他Channel交互。<br><img src="https://img-blog.csdnimg.cn/edee367f257d4e99bed4bd022bd46dd6.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5LiA5rGf5rqq5rC0,size_17,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><h4 id="Buffer"><a href="#Buffer" class="headerlink" title="Buffer"></a>Buffer</h4><p><img src="https://img-blog.csdnimg.cn/f0d063ff0fac40a88dfc149007f61bf0.png" alt="在这里插入图片描述"></p><p>缓冲区，本质是一块可读写数据的内存，用来简化数据读写。<br>Buffer三个重要属性：</p><ul><li>position下次读写数据的位置</li><li>limit 本次读写的极限位置</li><li>capacity 最大容量<ul><li>flip将写转为读，底层实现原理把position置0，并把limit设为当前的position值</li><li>clear将读转为写模式(用于读完全部数据的情况，把position置0，limit设为capacity)</li><li>compact将读转为写模式(用于存在未读数据的情况，让position指向未读数据的下一个)</li><li>通道方向和Buffer方向相反，读数据相当于向Buffer写，写数据相当于从Buffer读</li></ul></li></ul><p>使用步骤</p><ul><li>向Buffer写数据，调用flip方法转为读模式；</li><li>从Buffer中读数据，调用clear或compact方法清空缓冲区；</li></ul><h2 id="AIO"><a href="#AIO" class="headerlink" title="AIO"></a>AIO</h2><p>异步非阻塞IO，JDK1.7引入，服务器实现模式为一个有效请求对应一个线程，客户端的IO请求都是由操作系统先完成IO操作后再通知服务器应用来直接使用准备好的数据。适用连接数目多且连接时间长的场景。</p><ul><li>异步是指服务端线程接收到客户端管道后就交给底层处理IO通信，自己可以做其他事情</li><li>非阻塞是指客户端有数据才会处理，处理好再通知服务器。</li></ul><h4 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h4><ul><li>通过Future的get方法进行阻塞式调用</li><li>实现CompletionHandler接口，重写请求成功的回调方法completed 和请求失败回调方法failed </li></ul>]]></content>
      
      
      <categories>
          
          <category> 多线程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IO流 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring Bean的作用域和生命周期</title>
      <link href="/2021/10/02/spring-bean-de-zuo-yong-yu-he-sheng-ming-zhou-qi/"/>
      <url>/2021/10/02/spring-bean-de-zuo-yong-yu-he-sheng-ming-zhou-qi/</url>
      
        <content type="html"><![CDATA[<h2 id="Spring-Bean的作用域"><a href="#Spring-Bean的作用域" class="headerlink" title="Spring Bean的作用域"></a>Spring Bean的作用域</h2><p>Spring 为Bean定义了5种作用域，分别为：</p><ul><li>singleton (单例)</li><li>prototype (原型)</li><li>request</li><li>session </li><li>global session</li></ul><h3 id="singleton-单例模式（多线程下不安全）"><a href="#singleton-单例模式（多线程下不安全）" class="headerlink" title="singleton-单例模式（多线程下不安全）"></a>singleton-单例模式（多线程下不安全）</h3><ul><li>Spring loC容器中只会存在一 个共享的Bean实例，无论有多少个Bean引用它，始终指向同一个对象。</li><li>该模式在多线程下是不安全的。Singleton 作用域是Spring中的缺省作用域，也可以显示的将Bean定义为singleton模式</li></ul><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>userDao<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span> <span class="token punctuation">"</span>com.ioc.UserDaolmpl<span class="token punctuation">"</span></span> <span class="token attr-name">scope</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span> <span class="token punctuation">"</span>singleton<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="prototype-原型模式（每次使用时创建）"><a href="#prototype-原型模式（每次使用时创建）" class="headerlink" title="prototype-原型模式（每次使用时创建）"></a>prototype-原型模式（每次使用时创建）</h3><ul><li> 每次通过Spring容器获取prototype定义的bean时，容器都将创建一个新的Bean实例，每个Bean实例都有自己的属性和状态，而singleton全局只有一个对象。</li><li>一般来说,对有状态的bean使用prototype作用域，而对无状态的bean使用singleton作用域。</li></ul><h3 id="Request-（一次-request-创建一个实例）"><a href="#Request-（一次-request-创建一个实例）" class="headerlink" title="Request （一次 request 创建一个实例）"></a>Request （一次 request 创建一个实例）</h3><ul><li>在一次Http请求中，容器会返回该Bean的同一实例。 而对不同的Http请求则会产生新的Bean,而且该bean仅在当前Http Request 内有效</li><li>当前Http请求结束，该bean实例也将会被销毁。</li></ul><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span> <span class="token punctuation">"</span>loginAction<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>com.userLogin<span class="token punctuation">"</span></span> <span class="token attr-name">scope</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span> <span class="token punctuation">"</span>request<span class="token punctuation">'</span><span class="token punctuation">"</span></span><span class="token punctuation">/></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="session"><a href="#session" class="headerlink" title="session"></a>session</h3><ul><li>在一次Http Session中，容器会返回该Bean的同一实例。</li><li>而对不同的Session请求则会创建新的实例，该bean实例仅在当前Session 内有效。</li><li>同Http请求相同，每一次session请求创建新的实例，而不同的实例之间不共享属性，且实例仅在自己的session请求内有效，请求结束，则实例将被销毁。</li></ul><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span> userPreference<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span> com.ioc.UserPreference<span class="token punctuation">"</span></span> <span class="token attr-name">scope</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span> <span class="token punctuation">"</span>session<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="global-Session"><a href="#global-Session" class="headerlink" title="global Session"></a>global Session</h3><p>在一个全局的Http Session 中，容器会返回该Bean的同一个实例，仅在使用portlet context时有效。</p><h2 id="Spring-Bean的生命周期"><a href="#Spring-Bean的生命周期" class="headerlink" title="Spring Bean的生命周期"></a>Spring Bean的生命周期</h2><ol><li><p><strong>实例化</strong>一个Bean,也就是我们常说的new。</p></li><li><p><strong>IOC依赖注入</strong>，按照 Spring上下文对实例化的Bean进行配置，也就是IOC依赖注入。</p></li><li><p><strong>setBeanName实现</strong>，如果这个Bean已经实现了BeanNameAware接口，会调用它实现的setBeanName(String)方法，此处传递的就是Spring配置文件中Bean的id值</p></li><li><p><strong>BeanFactoryAware实现</strong>，如果这个Bean已经实现了BeanFactoryAware 接口，会调用它实现的setBeanFactory，setBeanFactory(BeanFactory)传递的是Spring工厂自身(可以用这个方式来获取其它Bean，只需在Spring配置文件中配置一个普通的Bean就可以)。</p></li></ol><ol start="5"><li><p><strong>ApplicationContextAware实现</strong>，如果这个 Bean已经实现了ApplicationContextAware接口，会调用<br>setApplicationContext(ApplicationContext)方法,传入Spring.上下文(同样这个方式也可以实现步骤4的内容，但比4更好,因为ApplicationContext是BeanFactory的子接口，有更多的实现方法)</p></li><li><p><strong>postProcessBeforelnitialization接口实现初始化预处理</strong>，如果这个Bean关联了BeanPostProcessor接口，将会调用postProcessBeforelnitialization(Object obj, String s)方法，BeanPostProcessor 经常被用作是Bean内容的更改，并且由于这个是在Bean初始化结束时调用那个的方法，也可以被应用于内存或缓存技术。</p></li><li><p><strong>init-method</strong>，如果 Bean在Spring配置文件中配置了init-method属性会自动调用其配置的初始化方法。</p></li><li><p><strong>postProcessAfterlnitialization</strong>，如果这个 Bean关联了BeanPostProcessor 接口，将会调用<br>postProcessAfterlnitialization(Object obj, String s)方法。<br>注:以上工作完成以后就可以应用这个Bean了,那这个Bean是一个Singleton的，所以一<br>般情况下我们调用同一个id的Bean会是在内容地址相同的实例，当然在Spring配置文件中<br>也可以配置非Singleton。</p></li><li><p><strong>Destroy过期自动清理阶段</strong>，当Bean不再需要时，会经过清理阶段,如果Bean实现了DisposableBean这个接口，会调用那个其实现的destroy()方法;</p></li><li><p><strong>destroy-method自配置清理</strong>，最后，如果这个Bean的Spring配置中配置了destroy-method属性,会自动调用其配置的销毁方法。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 框架 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>限流算法有哪些？</title>
      <link href="/2021/10/02/xian-liu-suan-fa-you-na-xie/"/>
      <url>/2021/10/02/xian-liu-suan-fa-you-na-xie/</url>
      
        <content type="html"><![CDATA[<p>在开发高并发系统时，有三把利器用来保护系统：</p><ul><li>缓存</li><li>降级</li><li>限流</li></ul><p>那么何为限流呢？顾名思义，限流就是限制流量，那又有那些限流算法呢？</p><h2 id="计数器算法"><a href="#计数器算法" class="headerlink" title="计数器算法"></a>计数器算法</h2><p>计数器限流算法，是指在指定的时间周期内累加访问次数,达到设定的需值时，触发限流策略。<br>下一个时间周期进行访问时，访问次数清零。此算法无论在单机还是分布式环境下实现都非常简单，使用redis的incr原子自增性,再结合key的过期时间，即可轻松实现。<br><img src="https://img-blog.csdnimg.cn/acd8164f89de46bfa67b8fff1149c755.png" alt="在这里插入图片描述"></p><ul><li>设置一个计数器计数器，每当一个请求过来的时候，计数器就加1，如果计数器的值大于100并且该请求与第一个 请求的间隔时间还在1分钟之内，那么说明请求数过多；</li><li>如果该请求与第一个请求的间隔时间大于1分钟，且计数器的值还在限流范围内，那么就重置 计数器</li></ul><p>这个算法实现简单，但是有一个十分致命的问题，那就是临界问题<br><img src="https://img-blog.csdnimg.cn/57e92cf031304c1a9d6a4644a9f0c322.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5LiA5rGf5rqq5rC0,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><h3 id="临界问题"><a href="#临界问题" class="headerlink" title="临界问题"></a>临界问题</h3><p>在第一个时间周期结束前的一秒进来100个请求，在第二个时间周期开始后一秒，进来100个请求，那么这个系统在两秒之内处理了200个请求，没有达到我们要求的限流</p><p>我们规定的是1分钟最多100个请求，也就是每秒大约1.7个请求，用户通过在时间窗口的重置节点处突发请求，可以瞬间超过我们的速率限制。用户有可能通过算法的这个漏洞，瞬间压垮我们的系统。</p><h2 id="滑动时间窗口"><a href="#滑动时间窗口" class="headerlink" title="滑动时间窗口"></a>滑动时间窗口</h2><p>为了应对计数器算法的临界问题，人们想出来滑动窗口算法。</p><ul><li>在TCP网络通信协议中。就采用滑动时间窗口算法来解决网络拥堵问题。</li><li>滑动时间官口是将计数箱算法中的实际周期切分成多个小的时间窗口，分别在每个小的时间官口中记录访问次数。</li><li>然后根据时间将官口往前滑动并删吟过期的小时间会口。最终只需要统计滑动官口范围内的小时间离口的总的清求数即可。</li></ul><p><img src="https://img-blog.csdnimg.cn/064eeb2427b244c2833f98a3370f9916.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5LiA5rGf5rqq5rC0,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><p>整个红色的矩形框表示一个时间窗口，一个时间窗口就是一分钟。然后我们将时间窗口进行划分</p><ul><li>比如图中，我们就将滑动窗口 划成了3格，所以每格代表的是20秒钟。</li><li>每过20秒钟，我们的时间窗口就会往右滑动一格，每一个格子都有自己独立的计数器</li><li>比如当一个请求 在0:12秒的时候到达，那么0:00~0:19对应的计数器就会加1。</li></ul><h3 id="滑动窗口是怎么解决计数器算法的临界问题的呢？"><a href="#滑动窗口是怎么解决计数器算法的临界问题的呢？" class="headerlink" title="滑动窗口是怎么解决计数器算法的临界问题的呢？"></a>滑动窗口是怎么解决计数器算法的临界问题的呢？</h3><p>还是刚才那个例子，0:59到达的100个请求会落在最后的黄色格子中，而1:00到达的请求会落在红色的格子中。当时间到达1:00时，我们的窗口会往右移动一格，那么此时时间周期窗口内的总请求数量一共是200个，超过了限定的一个周期100个，所以触发了限流。</p><ul><li>计数器算法和滑动窗口算法原理一致，滑动窗口算法就是计数器算法。只是计数器算法没有对时间窗口做进一步地划分，所以只有1格。</li><li>当滑动窗口的格子划分的越多，那么滑动窗口的滚动就越平滑，限流的统计就会越精确。</li></ul><h2 id="漏桶算法"><a href="#漏桶算法" class="headerlink" title="漏桶算法"></a>漏桶算法</h2><p>漏桶算法的原理就像它的名字一样, 我们维持一个漏斗， 它有恒定的流出速度,不管水流流入的速度有多快，漏斗出水的速度始终保持不变,类似于消息中间件,不管消息的生产者请求量有多大,消息的处理能力取决于消费者<br><img src="https://img-blog.csdnimg.cn/3c18214711f2423fbe29a3454cb84121.png" alt="在这里插入图片描述"></p><p>漏桶的容量=漏桶的流出速度*可接受的等待时长。</p><ul><li>在这个容量范围内的清求可以排队等待系统的处理，超过这个容量的清求，才会被抛弃。</li></ul><p>在漏桶限流算法中，存在下面几种情况:</p><ol><li>当清求速度大于漏桶的流出速度时，也就是清求量大于当前服务所能处理的最大极跟值时，触发限流策略.</li><li>请求速度小于或等于漏桶的流出速度时，也就是服务的处理能力大于或等于请求量时，正常执行。</li></ol><p>漏桶算法有一个缺点:</p><ul><li>当系统在短时间内有突发的大流量时，漏桶算法处理不了，相当于桶装不了那么大水</li></ul><h2 id="令牌桶算法"><a href="#令牌桶算法" class="headerlink" title="令牌桶算法"></a>令牌桶算法</h2><p>令牌桶算法，是增加一个大小固定的容著,也就是令牌桶，系统以恒定的速率向令牌桶中放入令牌,如果有客户端来请求，先需要从令牌桶中拿一个令牌，拿到令牌，才有资格访问系统，这时令牌桶中少一个令牌。当令牌桶满的时候，再向令牌桶生成令牌时，令牌会被抛弃。<br><img src="https://img-blog.csdnimg.cn/b8fa455214134741bc3731fb991f7859.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5LiA5rGf5rqq5rC0,size_17,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><p>在令牌桶算法中，存在以下几种情况:</p><ol><li>请求速度大于令牌的生成速度：那么令牌桶中的令牌会被取完，后续再进来的清求，由于拿不到令牌，会被限流。</li><li>清求速度等于令牌的生成速度：那么此时系统处于平稳状态。</li><li>请求速度小于令牌的生成速度:那么此时系统的访问量远远低于系统的并发能力，请求可以被正常处理,令牌桶算法，由于有一个桶的存在，可以处理短时间大流量的场景，这是令牌桶和漏桶的一个区别。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 分布式微服务 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 限流 </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL如何保证ACID</title>
      <link href="/2021/10/01/mysql-ru-he-bao-zheng-acid/"/>
      <url>/2021/10/01/mysql-ru-he-bao-zheng-acid/</url>
      
        <content type="html"><![CDATA[<h2 id="ACID"><a href="#ACID" class="headerlink" title="ACID"></a>ACID</h2><ol><li>原子性：事务是一个原子操作单元，其对数据的修改，要么全都执行，要么全都不执行</li><li>一致性：事务开始前和结束后，数据库的完整性约束没有被破坏。</li><li>隔离性：同一时间，只允许一个事务请求同一数据，不同的事务之间彼此没有任何干扰。</li><li>持久性：事务完成后，事务对数据库的所有更新将被保存到数据库，不能回滚。</li></ol><h2 id="undo-log"><a href="#undo-log" class="headerlink" title="undo log"></a>undo log</h2><ul><li>undoLog 也就是我们常说的回滚日志文件 主要用于事务中执行失败，进行回滚，以及MVCC中对于数据历史版本的查看。</li><li>undo log由引擎层的InnoDB引擎实现,是逻辑日志,记录数据修改被修改前的值,比如”把id=’B’ 修改为id = ‘B2’ ，那么undo日志就会用来存放id =’B’的记录”。</li><li>当一条数据需要更新前,会先把修改前的记录存储在undolog中,如果这个修改出现异常,则会使用undo日志来实现回滚操作,保证事务的一致性。</li><li>当事务提交之后，undo log并不能立马被删除,而是会被放到待清理链表中,待判断没有事物用到该版本的信息时才可以清理相应undolog。</li><li>它保存了事务发生之前的数据的一个版本，用于回滚，同时可以提供多版本并发控制下的读（MVCC），也即非锁定读。</li></ul><h2 id="redo-log"><a href="#redo-log" class="headerlink" title="redo log"></a>redo log</h2><ul><li>redoLog 是重做日志文件是记录数据修改之后的值，用于持久化到磁盘中。</li><li>redo log包括两部分<ul><li>一是内存中的日志缓冲(redo log buffer)，该部分日志是易失性的；</li><li>二是磁盘上的重做日志文件(redo log file)，该部分日志是持久的。由引擎层的InnoDB引擎实现,是物理日志,记录的是物理数据页修改的信息,比如“某个数据页上内容发生了哪些改动”。</li></ul></li><li>当一条数据需要更新时,InnoDB会先将数据更新，然后记录redoLog 在内存中，然后找个时间将redoLog的操作执行到磁盘上的文件上。</li><li>不管是否提交成功我都记录，你要是回滚了，那我连回滚的修改也记录。它确保了事务的持久性。</li><li>每个InnoDB存储引擎至少有1个重做日志文件组（group），每个文件组下至少有2个重做日志文件，如默认的ib_logfile0和ib_logfile1。</li><li>为了得到更高的可靠性，用户可以设置多个的镜像日志组（mirrored log groups），将不同的文件组放在不同的磁盘上，以此提高重做日志的高可用性。</li><li>在日志组中每个重做日志文件的大小一致，并以循环写入的方式运行。InnoDB存储引擎先写重做日志文件1，当达到文件的最后时，会切换至重做日志文件2，再当重做日志文件2也被写满时，会再切换到重做日志文件1中。</li></ul><h2 id="MVCC"><a href="#MVCC" class="headerlink" title="MVCC"></a>MVCC</h2><ul><li>MVCC多版本并发控制是MySQL中基于乐观锁理论实现隔离级别的方式，用于读已提交和可重复读取隔离级别的实现。</li><li>在MySQL中，会在表中每一条数据后面添加两个字段：最近修改该行数据的事务ID，指向该行（undolog表中）回滚段的指针。</li><li>Read View判断行的可见性，创建一个新事务时，copy一份当前系统中的活跃事务列表。</li><li>当前不应该被本事务看到的其他事务id列表。</li><li>已提交读隔离级别下的事务在每次查询的开始都会生成一个独立的ReadView,而可重复读隔离级别则在第一次读的时候生成一个ReadView，之后的读都复用之前的ReadView。</li></ul><h2 id="数据库如何保证原子性"><a href="#数据库如何保证原子性" class="headerlink" title="数据库如何保证原子性"></a>数据库如何保证原子性</h2><p>原子性由undolog日志来保证，它记录了需要回滚的日志信息，事务回滚时撤销已经执行成功的sql</p><h2 id="数据库如何保证隔离性"><a href="#数据库如何保证隔离性" class="headerlink" title="数据库如何保证隔离性"></a>数据库如何保证隔离性</h2><p>隔离性是由MVCC来保证</p><h2 id="数据库如何保证持久性"><a href="#数据库如何保证持久性" class="headerlink" title="数据库如何保证持久性"></a>数据库如何保证持久性</h2><p>持久性由redolog来保证，mysq|修改数据的时候会在redolog中记录一份日志数据，就算数据没有保存成功，只要日志保存成功了，数据仍然不会丢失</p><h2 id="数据库如何保证一致性"><a href="#数据库如何保证一致性" class="headerlink" title="数据库如何保证一致性"></a>数据库如何保证一致性</h2><p>一致性由其他三大特性保证，程序代码要保证业务上的一致性</p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ACID </tag>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AQS原理</title>
      <link href="/2021/09/22/aqs-yuan-li/"/>
      <url>/2021/09/22/aqs-yuan-li/</url>
      
        <content type="html"><![CDATA[<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>AQS是AbstarctQueuedSynchronizer 的简称 ，是一个用于构建锁和同步容器的框架。</p><p>juc并发 包内许多类都是基于 AQS 构建的</p><ul><li>ReentrantLock</li><li>ReentrantReadWriteLock</li><li>FutureTask</li></ul><p>AQS 解决了在实现同步容器时大量的细节问题。<br><img src="https://img-blog.csdnimg.cn/d49c82af4c5a4687806b853b3dd7065e.png" alt="在这里插入图片描述"></p><ul><li>AQS 使用一个 FIFO 队列表示排队等待锁的线程，队列头结点称作 “哨兵节点” ，它不与任何线程关联。</li><li>其他的节点与等待线程关联，每个阶段维护一个等待状态 waitStatus。</li></ul><h2 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h2><ul><li>独占锁：每次只能有一个线程持有锁， ReentrantLock 就是以独占方式实现的互斥锁；</li><li>共享锁：允许多个线程同时获取锁，并发访问共享资源，比如 ReentrantReadWriteLock。</li></ul><h2 id="内部原理"><a href="#内部原理" class="headerlink" title="内部原理"></a>内部原理</h2><p>AQS 的实现依赖内部的同步队列，也就是 FIFO 的双向队列，如果当前线程竞争锁失败，那么 AQS 会把当前线程以及等待状态信息构造成一个 Node 加入到同步队列中，同时再阻塞该线程。当获取锁的线程释放锁以后，会从队列中唤醒一个阻塞的节点 (线程)。<br><img src="https://img-blog.csdnimg.cn/8695a8335e9a4807877d1af86fe1b3d2.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5LiA5rGf5rqq5rC0,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>一个节点表示一个线程，它保存着线程的引用（thread）、状态（waitStatus）、前驱节点（prev）、后继节点（next），其实就是个双端双向链表</p><ul><li>AQS 队列内部维护的是一个 FIFO 的双向链表，这种结构的特点是每个数据结构都有两个指针，分别指向直接的后继节点和直接前驱节点。</li><li>双向链表可以从任意一个节点开始，很方便的访问前驱和后继。</li><li>每个 Node 其实是由线程封装，当线程争抢锁失败后会封装成 Node 加入到 ASQ 队列中去。</li></ul><h2 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h2><h4 id="添加线程"><a href="#添加线程" class="headerlink" title="添加线程"></a>添加线程</h4><p>当出现锁竞争以及释放锁的时候，AQS 同步队列中的节点会发生变化<br><img src="https://img-blog.csdnimg.cn/33188515e0eb44faa67106d48c0558ea.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5LiA5rGf5rqq5rC0,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><ul><li>队列操作的变化：新的线程封装成 Node 节点追加到同步队列中，设置 prev 节点以及修改当前节点的前置节点的 next 节点指向自己；</li><li>tail 指向变化：通过同步器将 tail 重新指向新的尾部节点。<h4 id="销毁线程"><a href="#销毁线程" class="headerlink" title="销毁线程"></a>销毁线程</h4>第一个 head 节点表示获取锁成功的节点，当头结点在释放同步状态时，会唤醒后继节点，如果后继节点获得锁成功，会把自己设置为头结点<br><img src="https://img-blog.csdnimg.cn/58333e8c7310454e819205749b8e93e9.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5LiA5rGf5rqq5rC0,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></li><li>head 节点指向：修改 head 节点指向下一个获得锁的节点；</li><li>新的获得锁的节点：第二个节点被 head 指向了，此时将 prev 的指针指向 null，因为它自己本身就是第一个首节点，所以 pre 指向 null。</li></ul><h2 id="AQS-与-ReentrantLock-的联系"><a href="#AQS-与-ReentrantLock-的联系" class="headerlink" title="AQS 与 ReentrantLock 的联系"></a>AQS 与 ReentrantLock 的联系</h2><p>ReentrantLock 是根据 AQS 实现的独占锁，提供了两个构造方法</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token class-name">ReentrantLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>       sync <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">NonfairSync</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token punctuation">&#125;</span>   <span class="token keyword">public</span> <span class="token class-name">ReentrantLock</span><span class="token punctuation">(</span><span class="token keyword">boolean</span> fair<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>       sync <span class="token operator">=</span> fair <span class="token operator">?</span> <span class="token keyword">new</span> <span class="token class-name">FairSync</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token keyword">new</span> <span class="token class-name">NonfairSync</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>ReentrantLock 有三个内部类：Sync，NonfairSync，FairSync<br><img src="https://img-blog.csdnimg.cn/52499b5bb0d5442c8c604837e047566c.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5LiA5rGf5rqq5rC0,size_13,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><p>这三个内部类都是基于 AQS 进行的实现，所以ReentrantLock 是基于 AQS 进行的实现。</p><p>ReentrantLock 提供两种类型的锁：</p><ul><li>公平锁-FairSync</li><li>非公平锁-NonfairSync</li><li>默认实现是 NonFairSync。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 多线程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 队列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>比较交换CAS</title>
      <link href="/2021/09/21/bi-jiao-jiao-huan-cas/"/>
      <url>/2021/09/21/bi-jiao-jiao-huan-cas/</url>
      
        <content type="html"><![CDATA[<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>CAS 是比较交换 CompareAndSwap 的简称，是一种用于在多线程环境下实现同步功能的机制。</p><p>顾名思义就是比较并交换。简单来说，从某一内存上取值 V，和预期值 A 进行比较</p><ul><li>如果内存值 V 和预期值 A 的结果相等，那么我们就把新值 B 更新到内存；</li><li>如果不相等，说明在这个过程中这个值被别的线程修改果，那么就重复上述操作直到成功为止。</li></ul><h2 id="为什么要CAS"><a href="#为什么要CAS" class="headerlink" title="为什么要CAS"></a>为什么要CAS</h2><h4 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h4><ul><li><p>在多线程中为了保持数据的准确性，避免多个线程同时操作某个变量，可以使用synchronized 实现同步锁。</p></li><li><p>使用 synchronized 关键字可以使操作的线程排队等待运行，可以说是一种悲观策略，认为线程会修改数据，所以开始就把持有锁的线程锁住，其他线程只能是挂起状态，等待锁的释放，所以同步锁带来了效率问题。</p></li></ul><h4 id="synchronized-的效率问题"><a href="#synchronized-的效率问题" class="headerlink" title="synchronized 的效率问题"></a>synchronized 的效率问题</h4><ul><li><p>在线程执行的时候，获得锁的线程在运行，其他被挂起的线程只能等待着持有锁的线程释放锁才有机会运行，时间浪费在阻塞等待上</p></li><li><p>在很多的线程切换的时候，由于有同步锁，就要涉及到锁的释放，加锁，这又是一个很大的时间开销。</p></li></ul><h4 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h4><ul><li><p>与阻塞机制相比有一种更有效地方法，即非阻塞机制，同步锁带来了线程执行时候之间的阻塞，而这种非阻塞机制在多个线程竞争同一个数据的时候不会发生阻塞的情况，效率大大提升</p></li><li><p>使用 volatile 不会造成阻塞，volatile 保证了线程之间的内存可见性和程序执行的有序性可以说已经很好的解决了上面的问题。</p></li><li><p>volatile存在原子操作问题，volatile 不能保证原子性，对于复合操作</p></li><li><p>例如 i++ 这样的程序包含三个原子操作：取值，自增，赋值。这个过程在多线程执行的时候就会有数据不一致的问题</p></li></ul><h2 id="CAS的意义"><a href="#CAS的意义" class="headerlink" title="CAS的意义"></a>CAS的意义</h2><ul><li>CAS（Compare And Swap 比较和交换）解决了 volatile 不能保证原子性的问题；</li><li>CAS 操作即能够解决锁的效率问题，也能够保证操作的原子性。</li></ul><h2 id="CAS-操作原理"><a href="#CAS-操作原理" class="headerlink" title="CAS 操作原理"></a>CAS 操作原理</h2><p>CAS 主要包含三个操作数，内存位置 V，原值 A，和新值 B。</p><ul><li>当位置 V 的值与 A 相等时，CAS 才会通过原子方式用新值 B 来更新 V，</li><li>否则不会进行任何操作。无论位置 V 的值是否等于 A，都将返回 V 原有的值。</li></ul><p>CAS 是一种乐观策略，每次都正常操作，不用担心其他线程会修改变量等数据，只在最后提交的时候验证数据是否被更改，如果其数据被更改，那么 CAS 会检测到并利用算法重新计算。</p><ul><li>CAS 也是同时允许一个线程修改变量，其他的线程试图修改都将失败；</li><li>相比于同步锁，CAS 对于失败的线程不会将他们挂起，下次仍可以继续提交，参与竞争，这也就是非阻塞机制的特点。</li></ul><h2 id="存在问题"><a href="#存在问题" class="headerlink" title="存在问题"></a>存在问题</h2><h4 id="ABA-问题"><a href="#ABA-问题" class="headerlink" title="ABA 问题"></a>ABA 问题</h4><p>假设有两个线程，线程 1 和线程 2，线程 1 工作时间需要 6 秒，线程 2 工作需要 2 秒，主内存值为 A；</p><ul><li>第 1 秒，线程 1 和线程 2 都把 A 拿到自己的工作内存；</li><li>第 2 秒，线程 2 开始执行，线程 2 工作完成把 A 改成了 B ；</li><li>第 4 秒，线程 2 把 B 又改成了 A；</li><li>第 6秒，线程 1 看到期望为 A ，和真实值也是 A， 认为没有线程修改过数据，其实 A 已经修改过了，后来又改了回去，然后线程 1 进行 CAS 操作。<h4 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h4>为了解决这个问题，在每次进行操作的时候加上一个版本号即可，要求这个版本号只能增加，不能减少</li></ul>]]></content>
      
      
      <categories>
          
          <category> 多线程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CAS </tag>
            
            <tag> 乐观锁 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何保证消息的可靠性传输</title>
      <link href="/2021/09/20/ru-he-bao-zheng-xiao-xi-de-ke-kao-xing-chuan-shu/"/>
      <url>/2021/09/20/ru-he-bao-zheng-xiao-xi-de-ke-kao-xing-chuan-shu/</url>
      
        <content type="html"><![CDATA[<p>在生产环境中，因为机器以及网络设备的不可靠，保证消息的可靠是待解决的问题。在特定场景下消息可能存在丢失风险</p><h2 id="消息发送流程"><a href="#消息发送流程" class="headerlink" title="消息发送流程"></a>消息发送流程</h2><p>我们可以将 RabbitMQ 消息处理的过程分为三个步骤：</p><ul><li>生产阶段：生产者生产消息并且发送到消息队列；</li><li>储存阶段：消息队列存储和处理消息；</li><li>消费阶段：消息队列将消息转发到消费者。</li></ul><p>上述每个步骤都有可能出现消息丢失的风险；<br><img src="https://img-blog.csdnimg.cn/13d87d272eb54fddb92fcbd6d1faf0a1.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5LiA5rGf5rqq5rC0,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><h2 id="生产者生产消息并且发送到消息队列"><a href="#生产者生产消息并且发送到消息队列" class="headerlink" title="生产者生产消息并且发送到消息队列"></a>生产者生产消息并且发送到消息队列</h2><h4 id="丢失场景"><a href="#丢失场景" class="headerlink" title="丢失场景"></a>丢失场景</h4><p>生产者将数据发送到 RabbitMQ 的时候，可能数据就在半路给搞丢了，比如：</p><ul><li>网络故障。网络环境的不可靠导致消息发送失败，例如网络丢包、网络故障。</li><li>数据在网络中传输会经过诸多网络设备，只要其中一个网络链接在数据抵达前已经流量满载，新到的数据将会阻塞一段时间段。</li></ul><h4 id="AMQP事务机制"><a href="#AMQP事务机制" class="headerlink" title="AMQP事务机制"></a>AMQP事务机制</h4><p>使用AMQP协议的事务机制。生产者在发出消息之后，消息是否到达RabbitMQ服务器是默认不可知的，在生产者发送消息之前，调用channel.txSelect 语句开启事务</p><ul><li>如果消息发送失败，那么调用channel.txRollback回滚事务，尝试重新发送一条消息；</li><li>如果消息发送成功，那么调用channel.txCommit提交事务。</li></ul><p>采用事务的缺点是增加耗时，会降低RabbitMQ的吞吐性能。</p><h4 id="Confirm机制"><a href="#Confirm机制" class="headerlink" title="Confirm机制"></a>Confirm机制</h4><p>RabbitMQ有一种性能改进方案，即Confirm机制</p><ul><li>生产者调用channel.confirmSelect将通信方式设置为confirm模式；</li><li>生产者发送的所有消息都会被分配一个唯一 ID；</li><li>当生产者发送的消息成功投递到队列之后，RabbitMQ会发送一个ack给生产者，生产者即得知这条消息已经成功发送。</li><li>如果 RabbitMQ 没能处理这个消息，会回调你一个nack接口，告诉你这个消息接收失败，需要重试</li></ul><p>我们也可以结合这个机制在内存里维护每个消息 id 的状态，如果超过一定时间还没接收到这个消息的回调，那么就需要重新发送</p><h4 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h4><ul><li>事务机制是同步的，你提交一个事务之后会阻塞在那里</li><li>confirm机制是异步的，发送消息之后就可以发送下一个消息，然后那个消息RabbitMQ 接收了之后会异步回调你一个接口通知你这个消息接收到了。</li></ul><h2 id="消息队列存储和处理消息"><a href="#消息队列存储和处理消息" class="headerlink" title="消息队列存储和处理消息"></a>消息队列存储和处理消息</h2><p>消息存储在 RabbitMQ 队列中，如果队列没有持久化，如果服务器宕机，RabbitMQ 服务器重启后会导致消息丢失。</p><h4 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h4><p>开启 RabbitMQ 的持久化，就是消息写入之后会持久化到磁盘，如果 RabbitMQ 自己宕机了，重启之后会自动读取之前存储的数据；</p><p>也有可能RabbitMQ 还没持久化，就宕机了，这种情况发生的概率比较小</p><p>持久化也可以跟生产者的confirm机制配合起来，只有消息被持久化到磁盘之后，才给生产者发送ack，所以哪怕是出现上面这种情况，RabbitMQ 宕机了，消息丢了，生产者收不到ack，还是回重发的。</p><h4 id="消息队列持久化"><a href="#消息队列持久化" class="headerlink" title="消息队列持久化"></a>消息队列持久化</h4><ul><li><p>Exchange 持久化：以 Direct 模式为例，将 durable 参数设置为 true。</p></li><li><p>Queue 持久化：将 durable 参数设置为 true，但是这样只能保证持久化 Queue 的元数据，但是不会持久化 Queue 里存储的消息。</p></li><li><p>消息持久化：发送消息的时候将deliveryMode设置为2，将消息设置为持久化的</p></li><li><p>SpringBoot中的rabbitTemplate默认设置消息是持久化，不需要手动配置</p></li></ul><h2 id="消息队列将消息转发到消费者"><a href="#消息队列将消息转发到消费者" class="headerlink" title="消息队列将消息转发到消费者"></a>消息队列将消息转发到消费者</h2><p>消费者在收到消息之后，还没来得及处理消息的消费逻辑，所在机器就宕机了，导致内存中的消息丢失。</p><h4 id="解决方案-1"><a href="#解决方案-1" class="headerlink" title="解决方案"></a>解决方案</h4><p>RabbitMQ 默认采用自动 ACK 机制，在没有处理业务逻辑之前，消费者就会告知消息队列已经成功收到消息，这种方式并不能解决这种问题</p><ul><li>我们可以关闭自动ACK模式，通过一个 调用API接口就行，消费完消息后，再返回ACK。这样的话，如果你还没处理完，就没有ACK</li><li>这样 RabbitMQ 就认为你还没处理完，这个时候 RabbitMQ 会把这个消费分配给别的 consumer 去处理，消息是不会丢的。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 消息队列 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RabbitMQ </tag>
            
            <tag> 可靠性 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>volatile 关键字</title>
      <link href="/2021/09/19/volatile-guan-jian-zi/"/>
      <url>/2021/09/19/volatile-guan-jian-zi/</url>
      
        <content type="html"><![CDATA[<h2 id="volatile-关键字"><a href="#volatile-关键字" class="headerlink" title="volatile 关键字"></a>volatile 关键字</h2><ul><li>volatile 关键字解决内存可见性问题，是一种弱形式的同步。</li><li>该关键字可以确保当一个线程更新共享变量时，更新操作对其他线程马上可见。</li><li>当一个变量被声明为 volatile 时，线程在写入变量时不会把值缓存在寄存器或者其他地方，而是会把值刷新回主内存。</li><li>当其他线程读取该共享变量时，会从主内存重新获取最新值，而不是使用当前线程的工作内存中的值。</li></ul><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>Java 语言提供了一种弱同步机制，即 volatile 变量，用来确保将变量的更新操作通知到其他线程。</p><p>当把变量声明为 volatile 类型后，编译器与运行时都会注意到这个变量是共享的，volatile 变量不会被缓存在寄存器或者对其他处理器不可见的地方，因此在读取 volatile 类型的变量时总会返回最新写入的值。</p><p>在访问 volatile 变量时不会执行加锁操作，因此也就不会使执行线程阻塞，因此 volatile 变量是一种比 sychronized 关键字更轻量级的同步机制。</p><p><img src="https://img-blog.csdnimg.cn/9e8d11a885064a3ab64812f35796106b.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5LiA5rGf5rqq5rC0,size_19,color_FFFFFF,t_70,g_se,x_16"></p><ul><li><p>当对非 volatile 变量进行读写的时候，每个线程先从内存拷贝变量到 CPU 缓存中。如果计算机有多个 CPU，每个线程可能在不同的 CPU 上被处理，这意味着每个线程可以拷贝到不同的 CPU cache 中。</p></li><li><p>而声明变量是 volatile 的，JVM 保证了每次读变量都从内存中读，跳过 CPU cache。</p></li></ul><h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><ul><li>保证变量的可见性</li><li>禁止指令重排</li></ul><h4 id="保证变量的可见性"><a href="#保证变量的可见性" class="headerlink" title="保证变量的可见性"></a>保证变量的可见性</h4><p>当一条线程修改了变量值，新值对于其他线程来说是立即可以得知的。volatile 变量在各个线程的<br>工作内存中不存在-致性问题，但Java的运算操作符并非原子操作，导致volatile变量运算在并<br>发下仍不安全。</p><h4 id="禁止指令重排"><a href="#禁止指令重排" class="headerlink" title="禁止指令重排"></a>禁止指令重排</h4><p>使用volatile变量进行写操作，汇编指令带有lock前缀，相当于一个内存屏障，后面的指令不能<br>重排到内存屏障之前。</p><h4 id="使用lock前缀引发两件事"><a href="#使用lock前缀引发两件事" class="headerlink" title="使用lock前缀引发两件事:"></a>使用lock前缀引发两件事:</h4><ol><li>将当前处理器缓存行的数据写回系统内存。</li><li>使其他处理器的缓存无效。</li></ol><p>相当于对缓存变量做了- -次store和write操作，让volatile变量的修改对其他处理器立即可见。</p><h2 id="volatile-与-synchronized-的区别"><a href="#volatile-与-synchronized-的区别" class="headerlink" title="volatile 与 synchronized 的区别"></a>volatile 与 synchronized 的区别</h2><h4 id="相似处："><a href="#相似处：" class="headerlink" title="相似处："></a>相似处：</h4><p>volatile 的内存语义和 synchronized 有相似之处，具体来说就是，当线程写入了 volatile 变量值时就等价于线程退出 synchronized 同步块（把写入工作内存的变量值同步到主内存），读取 volatile 变量值时就相当于进入 synchronized 同步块（ 先清空本地内存变量值，再从主内存获取最新值）。</p><h4 id="区别："><a href="#区别：" class="headerlink" title="区别："></a>区别：</h4><p>使用锁的方式可以解决共享变量内存可见性问题，但是使用锁太笨重，因为它会带来线程上下文的切换开销。具体区别如下：</p><ul><li>volatile 本质是在告诉 jvm 当前变量在寄存器（工作内存）中的值是不确定的，需要从主存中读取；</li><li>synchronized 则是锁定当前变量，只有当前线程可以访问该变量，其他线程被阻塞住；</li><li>volatile 仅能使用在变量级别；synchronized 则可以使用在变量、方法、和类级别的；</li><li>volatile 仅能实现变量的修改可见性，不能保证原子性；而 synchronized 则可以保证变量的修改可见性和原子性；</li><li>volatile 不会造成线程的阻塞；synchronized 可能会造成线程的阻塞；</li><li>volatile 标记的变量不会被编译器优化；synchronized 标记的变量可以被编译器优化</li></ul>]]></content>
      
      
      <categories>
          
          <category> 多线程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> volatile </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JDK的锁优化策略</title>
      <link href="/2021/09/19/jdk-de-suo-you-hua-ce-lue/"/>
      <url>/2021/09/19/jdk-de-suo-you-hua-ce-lue/</url>
      
        <content type="html"><![CDATA[<h2 id="锁的优化策略"><a href="#锁的优化策略" class="headerlink" title="锁的优化策略"></a>锁的优化策略</h2><ul><li>JDK6对synchronized做了很多优化，引入了自适应自旋、锁消除、锁粗化、偏向锁和轻量级锁等优化策略，提高锁的效率；</li><li>锁一共有4个状态，级别从低到高依次是:无锁、偏向锁、轻量级锁和重量级锁，状态会随竞争情况升级。</li><li>锁可以升级但不能降级，这种只能升级不能降级的锁策略是为了提高锁获得和释放的效率。</li></ul><h2 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h2><ul><li>线程同步对性能最大的影响是阻塞，挂起和恢复线程的操作都需要从用户态转入内核态完成。</li><li>许多应用上共享数据的锁定只会持续很短的时间，为了这段时间去挂起和恢复线程并不值得。</li><li>如果机器有多个处理器核心，我们可以让后面请求锁的线程稍等一会， 但不放弃处理器的执行时间，看看持有锁的线程是否很快会释放锁。</li><li>为了让线程等待只需让线程执行一个循环，这项技术就是自旋锁。</li></ul><p>自旋锁在JDK4就已引入，默认关闭，在JDK6中改为默认开启。自旋不能代替阻塞，虽然避免了线程<br>切换开销，但要占用处理器时间。</p><ul><li>如果锁被占用的时间很短，自旋的效果就会非常好，反之只会白白消耗处理器资源。</li><li>如果自旋超过了限定的次数仍然没有成功获得锁，就应挂起线程，自旋默认限定次数是10</li></ul><h3 id="自适应自旋"><a href="#自适应自旋" class="headerlink" title="自适应自旋"></a>自适应自旋</h3><ul><li>JDK6对自旋锁进行了优化，自旋时间不再固定，而是由前一次的自旋时间及锁拥有者的状态决定。</li><li>如果在同一个锁上，自旋刚刚成功获得过锁且持有锁的线程正在运行，虚拟机会认为这次自旋也很可能成功，进而允许自旋持续更久。</li><li>如果自旋很少成功，以后获取锁时将可能直接省略掉自旋，避免浪费处理器资源。有了自适应自旋，随着程序运行时间的增长，虚拟机对程序锁的状况预测就会越来越精准。</li></ul><h2 id="锁消除"><a href="#锁消除" class="headerlink" title="锁消除"></a>锁消除</h2><ul><li>锁消除指即时编译器对检测到不可能存在共享数据竞争的锁进行消除。</li><li>主要判定依据来源于逃逸分析，如果判断一段代码中堆上的所有数据都只被一个线程访问，就可以当作栈上的数据对待，认为它们是线程私有的而无须同步。<h2 id="锁粗化"><a href="#锁粗化" class="headerlink" title="锁粗化"></a>锁粗化</h2></li><li>一般来说需要将同步块的作用范围限制得尽量小，只在共享数据的实际作用域中进行同步，这是为了使等待锁的线程尽快拿到锁。</li><li>但如果一系列的连续操作都对同一个对象反复加锁和解锁，甚至加锁操作是出现在循环体之外的，即使没有线程竞争也会导致不必要的性能消耗。</li><li>因此如果虚拟机探测到有一串零碎的操作都对同一个对象加锁，将会把同步的范围扩展到整个操作序列的外部。</li></ul><h2 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h2><ul><li>偏向锁是为了在没有竞争的情况下减少锁开销，锁会偏向于第一个获得它的线程，如果在执行过程中锁一直没有被其他线程获取，则持有偏向锁的线程将不需要进行同步。</li><li>当锁对象第一次被线程获取时，虚拟机会将对象头中的偏向模式设为1，同时使用CAS把获取到锁的线<br>程ID记录在对象的Mark Word中。</li><li>如果CAS成功，持有偏向锁的线程以后每次进入锁相关的同步块都不再进行任何同步操作。</li><li>一旦有其他线程尝试获取锁，偏向模式立即结束，根据锁对象是否处于锁定状态决定是否撤销偏向，后续同步按照轻量级锁那样执行。</li></ul><h2 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h2><p>轻量级锁是为了在没有竞争的前提下减少重量级锁使用操作系统互斥量产生的性能消耗。</p><p>在代码即将进入同步块时，如果同步对象没有被锁定，虚拟机将在当前线程的栈帧中建立一个锁记录空<br>间，存储锁对象目前Mark Word的拷贝。然后虚拟机使用CAS尝试把对象的Mark Word更新为指向<br>锁记录的指针，如果更新成功即代表该线程拥有了锁，锁标志位将转变为00，表示处于轻量级锁定状<br>念。</p><p>如果更新失败就意味着至少存在一条线程与当前线程竞争。虚拟机检查对象的Mark Word是否指向当<br>前线程的栈帧，如果是则说明当前线程已经拥有了锁，直接进入同步块继续执行，否则说明锁对象已经<br>被其他线程抢占。如果出现两条以上线程争用同一个锁，轻量级锁就不再有效，将膨胀为重量级锁，锁<br>标志状态变为10，此时Mark Word存储的就是指向重量级锁的指针，后面等待锁的线程也必须阻塞。</p><p>解锁同样通过CAS进行，如果对象Mark Word仍然指向线程的锁记录，就用CAS把对象当前的Mark<br>Word和线程复制的Mark Word替换回来。假如替换成功同步过程就顺利完成了，如果失败则说明有<br>其他线程尝试过获取该锁，就要在释放锁的同时唤醒被挂起的线程。</p><h2 id="偏向锁、轻量级锁和重量级锁之间的区别"><a href="#偏向锁、轻量级锁和重量级锁之间的区别" class="headerlink" title="偏向锁、轻量级锁和重量级锁之间的区别?"></a>偏向锁、轻量级锁和重量级锁之间的区别?</h2><ul><li>偏向锁的优点是加解锁不需要额外消耗，和执行非同步方法比仅存在纳秒级差距，缺点是如果存在锁竞争会带来额外锁撤销的消耗，适用只有一个线程访问同步代码块的场景。</li><li>轻量级锁的优点是竞争线程不阻塞，程序响应速度快，缺点是如果线程始终得不到锁会自旋消耗CPU,适用追求响应时间、同步代码块执行快的场景。</li><li>重量级锁的优点是线程竞争不使用自旋不消耗CPU，缺点是线程会阻塞,响应时间慢，适应追求吞吐<br>量、同步代码块执行慢的场景。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 多线程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 锁 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>synchronized关键字</title>
      <link href="/2021/09/17/synchronized-guan-jian-zi/"/>
      <url>/2021/09/17/synchronized-guan-jian-zi/</url>
      
        <content type="html"><![CDATA[<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>synchronized 同步块是 Java 提供的一种原子性内置锁，Java 中的每个对象都可以把它当作一个同步锁来使用，这些 Java 内置的使用者看不到的锁被称为内部锁，也叫作监视器锁。</p><h4 id="内置锁"><a href="#内置锁" class="headerlink" title="内置锁"></a>内置锁</h4><ul><li><p>也叫排它锁，也就是当一个线程获取这个锁后，其他线程必须等待该线程释放锁后才能获取该锁。</p></li><li><p>代码在进入 synchronized 代码块前会自动获取内部锁，这时候其他线程访问该同步代码块时会被阻塞挂起。</p></li><li><p>拿到内部锁的线程会在正常退出同步代码块或者抛出异常后或者在同步块内调用了该内置锁资源的 wait 系列方法时释放该内置锁。</p></li></ul><h4 id="上下文切换"><a href="#上下文切换" class="headerlink" title="上下文切换"></a>上下文切换</h4><p>由于 Java 中的线程是与操作系统的线程一一对应的，所以当阻塞一个线程时，需要从用户态切换到内核态执行阻塞操作，这是很耗时的操作，这就是上下文切换，而 synchronized 的使用就会导致上下文切换。</p><h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><p>在并发编程中存在线程安全问题，使用 synchronized 关键字能够有效的避免多线程环境下的线程安全问题。</p><h4 id="线程安全问题"><a href="#线程安全问题" class="headerlink" title="线程安全问题"></a>线程安全问题</h4><ul><li>存在共享数据，共享数据是对多线程可见的，所有的线程都有权限对共享数据进行操作；</li><li>多线程共同操作共享数据。关键字 synchronized 可以保证在同一时刻，只有一个线程可以执行某个同步方法或者同步代码块，同时 synchronized 关键字可以保证一个线程变化的可见性；</li><li>多线程共同操作共享数据且涉及增删改操作。如果只是查询操作，是不需要使用 synchronized 关键字的，在涉及到增删改操作时，为了保证数据的准确性，可以选择使用 synchronized 关键字。</li></ul><h2 id="三种使用方式"><a href="#三种使用方式" class="headerlink" title="三种使用方式"></a>三种使用方式</h2><p>Java 中每一个对象都可以作为锁，synchronized 有三种使用方式</p><ul><li>作用在普通同步方法（实例方法）：锁是当前实例对象 ，进入同步代码前要获得当前实例的锁；</li><li>作用在静态同步方法：锁是当前类的 class 对象 ，进入同步代码前要获得当前类对象的锁；</li><li>作用在同步方法块：锁是括号里面的对象，对给定对象加锁，进入同步代码库前要获得给定对象的锁。</li></ul><h2 id="双重检验锁实现单例模式"><a href="#双重检验锁实现单例模式" class="headerlink" title="双重检验锁实现单例模式"></a>双重检验锁实现单例模式</h2><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">DoubleCheck</span><span class="token punctuation">&#123;</span>    <span class="token keyword">private</span> <span class="token keyword">volatile</span> <span class="token keyword">static</span> <span class="token class-name">DoubleCheck</span> instance<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token class-name">DoubleCheck</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">synchronized</span> <span class="token keyword">static</span> <span class="token class-name">DoubleCheck</span> <span class="token function">getIntstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token comment">//先判断对象是否实例过，没有则进入加锁代码</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>instance <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token comment">//类对象加锁</span>            <span class="token keyword">synchronized</span><span class="token punctuation">(</span><span class="token class-name">DoubleCheck</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>instance <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                    instance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">DoubleCheck</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> instance<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>使用synchronized关键字，内外两次判断对象是否存在</li><li>必须使用volatile关键字修饰，防止jvm指令重排</li></ul>]]></content>
      
      
      <categories>
          
          <category> 多线程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 锁 </tag>
            
            <tag> synchronized </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>扩展线程池捕获线程异常</title>
      <link href="/2021/09/15/kuo-zhan-xian-cheng-chi-bu-huo-xian-cheng-yi-chang/"/>
      <url>/2021/09/15/kuo-zhan-xian-cheng-chi-bu-huo-xian-cheng-yi-chang/</url>
      
        <content type="html"><![CDATA[<h2 id="如何捕获线程池中的线程异常"><a href="#如何捕获线程池中的线程异常" class="headerlink" title="如何捕获线程池中的线程异常"></a>如何捕获线程池中的线程异常</h2><h3 id="简单案例"><a href="#简单案例" class="headerlink" title="简单案例"></a>简单案例</h3><p>我们先看一个案例，实现Runnable接口，计算两个数的商<br><img src="https://img-blog.csdnimg.cn/412d931173c34e70ae14e23a7236c8cb.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5LiA5rGf5rqq5rC0,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>创建一个线程池，参数如下<br><img src="https://img-blog.csdnimg.cn/a274f18d22894035b24ed64b36fe2835.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5LiA5rGf5rqq5rC0,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>提交任务到线程池，查看执行结果<br><img src="https://img-blog.csdnimg.cn/2cea315595974aab8d54688a7d456f14.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5LiA5rGf5rqq5rC0,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>执行结果<br><img src="https://img-blog.csdnimg.cn/c9999b695a714397aa4b35c320caef04.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5LiA5rGf5rqq5rC0,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><ul><li>我们发现，我们代码中，提交了5个线程，但最终只打印了4个结果，</li><li>而且没有报何错误，很明显100/0的那个任务没有打印</li><li>100/0会报除零异常，但是显然这次没有报任何错误</li></ul><h3 id="改用execute-提交线程"><a href="#改用execute-提交线程" class="headerlink" title="改用execute()提交线程"></a>改用execute()提交线程</h3><p>为了获得线程报错信息，我们可以改用execute()提交线程<br><img src="https://img-blog.csdnimg.cn/0066bbf997c746beae88e10f83264575.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5LiA5rGf5rqq5rC0,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><ul><li>从这里的控制台，我们得到了部分的报错信息，但是我们只能知道异常是在哪里抛出来的，ThreadPoolTest.java的第51行；</li><li>但是我们还是希望得到其他的更重要的信息，这个任务在哪里提交的？<h3 id="扩展线程池ThreadPoolExecutor"><a href="#扩展线程池ThreadPoolExecutor" class="headerlink" title="扩展线程池ThreadPoolExecutor"></a>扩展线程池ThreadPoolExecutor</h3>我们可以扩展一下ThreadPoolExecutor这个线程池，让他在任务调度前，先保存一下提交任务线程的堆栈信息</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">package</span> <span class="token namespace">com<span class="token punctuation">.</span>stream<span class="token punctuation">.</span>juc</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span></span><span class="token class-name">BlockingQueue</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span></span><span class="token class-name">Future</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span></span><span class="token class-name">ThreadPoolExecutor</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span></span><span class="token class-name">TimeUnit</span><span class="token punctuation">;</span><span class="token comment">/** * 扩展线程池 * 捕获线程池的异常 * * @author stream * @since 2021/9/15 7:51 */</span><span class="token keyword">class</span> <span class="token class-name">ExtenThreadPoolExecutor</span> <span class="token keyword">extends</span> <span class="token class-name">ThreadPoolExecutor</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token class-name">ExtenThreadPoolExecutor</span><span class="token punctuation">(</span><span class="token keyword">int</span> corePoolSize<span class="token punctuation">,</span> <span class="token keyword">int</span> maximumPoolSize<span class="token punctuation">,</span> <span class="token keyword">long</span> keepAliveTime<span class="token punctuation">,</span> <span class="token class-name">TimeUnit</span> unit<span class="token punctuation">,</span> <span class="token class-name">BlockingQueue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Runnable</span><span class="token punctuation">></span></span> workQueue<span class="token punctuation">,</span> <span class="token class-name">CallerRunsPolicy</span> callerRunsPolicy<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">super</span><span class="token punctuation">(</span>corePoolSize<span class="token punctuation">,</span> maximumPoolSize<span class="token punctuation">,</span> keepAliveTime<span class="token punctuation">,</span> unit<span class="token punctuation">,</span> workQueue<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">execute</span><span class="token punctuation">(</span><span class="token class-name">Runnable</span> command<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span><span class="token function">wrap</span><span class="token punctuation">(</span>command<span class="token punctuation">,</span><span class="token function">clientTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token class-name">Future</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">></span></span> <span class="token function">submit</span><span class="token punctuation">(</span><span class="token class-name">Runnable</span> task<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">submit</span><span class="token punctuation">(</span><span class="token function">wrap</span><span class="token punctuation">(</span>task<span class="token punctuation">,</span><span class="token function">clientTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token comment">// 抛出异常信息</span>    <span class="token keyword">private</span> <span class="token class-name">Exception</span> <span class="token function">clientTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Exception</span><span class="token punctuation">(</span><span class="token string">"Thread Stack"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">private</span> <span class="token class-name">Runnable</span> <span class="token function">wrap</span><span class="token punctuation">(</span><span class="token class-name">Runnable</span> task<span class="token punctuation">,</span> <span class="token class-name">Exception</span> exception <span class="token punctuation">,</span> <span class="token class-name">String</span> name<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Runnable</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token annotation punctuation">@Override</span>            <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>                    task<span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 捕获异常</span>                <span class="token punctuation">&#125;</span><span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                    exception<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token keyword">throw</span> e<span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们用扩展后的线程池提交任务，还是刚才的代码<br><img src="https://img-blog.csdnimg.cn/f585e3e0943b4c089071ef9f7df94552.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5LiA5rGf5rqq5rC0,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>这样，我们就得到了异常发生的内部堆栈信息，帮助我们快速定位问题</p>]]></content>
      
      
      <categories>
          
          <category> 多线程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 线程池 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ThreadLocal的使用</title>
      <link href="/2021/09/15/threadlocal-de-shi-yong/"/>
      <url>/2021/09/15/threadlocal-de-shi-yong/</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>ThreadLocal 为解决多线程程序的并发问题提供了一种新的思路，使用这个工具类可以很简洁地编写出优美的多线程程序。</p><ul><li><p>ThreadLocal 很容易让人望文生义，想当然地认为是一个 “本地线程”。其实，ThreadLocal 并不是一个 Thread，而是 Thread 的局部变量，也许把它命名为 ThreadLocalVariable 更容易让人理解一些。</p></li><li><p>当使用 ThreadLocal 维护变量时，ThreadLocal 为每个使用该变量的线程提供独立的变量副本，所以每一个线程都可以独立地改变自己的副本，而不会影响其它线程所对应的副本。</p></li></ul><p>从线程的角度看，目标变量就象是线程的本地变量，这也是类名中 “Local” 所要表达的意思。</p><h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><p>ThreadLocal提供了线程本地变量，如果你创建了一个 ThreadLocal 变量，那么访问这个变量的每个线程都会有这个变量的一个本地副本。当多个线程操作这个变量时，实际操作的是自己本地内存里面的变量，从而避免了线程安全问题。<br><img src="https://img-blog.csdnimg.cn/da73098b996a4ca582c20451c3665a3c.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5LiA5rGf5rqq5rC0,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><p>ThreadLocal 是线程本地存储，在每个线程中都创建了一个 ThreadLocalMap 对象，每个线程可以访问自己内部 ThreadLocalMap 对象内的 value。通过这种方式，避免资源在多线程间共享。</p><h2 id="set-和get-方法"><a href="#set-和get-方法" class="headerlink" title="set()和get()方法"></a>set()和get()方法</h2><p>set 方法是为了设置 ThreadLocal 变量，设置成功后，该变量只能够被当前线程访问，其他线程不可直接访问操作改变量。参数是泛型<br><img src="https://img-blog.csdnimg.cn/add11667446f4362b06ddd7dd0650846.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5LiA5rGf5rqq5rC0,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><p>get 方法是为了获取 ThreadLocal 变量的值，get 方法没有任何入参，直接调用即可获取。<br><img src="https://img-blog.csdnimg.cn/402c399592cb48ac9707f2629e92f9ca.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5LiA5rGf5rqq5rC0,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><h2 id="remove-方法"><a href="#remove-方法" class="headerlink" title="remove() 方法"></a>remove() 方法</h2><p>remove 方法是为了清除 ThreadLocal 变量，清除成功后，该 ThreadLocal 中没有变量值。<br><img src="https://img-blog.csdnimg.cn/144cb735fb68441f9b4db94121c50f34.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5LiA5rGf5rqq5rC0,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><h2 id="单线程使用案例"><a href="#单线程使用案例" class="headerlink" title="单线程使用案例"></a>单线程使用案例</h2><p><img src="https://img-blog.csdnimg.cn/d06fb2b2ea2e4d96a728e4cc6a93099f.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5LiA5rGf5rqq5rC0,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><h2 id="多线程下的-ThreadLocal使用案例"><a href="#多线程下的-ThreadLocal使用案例" class="headerlink" title="多线程下的 ThreadLocal使用案例"></a>多线程下的 ThreadLocal使用案例</h2><p>看个简单案例</p><ul><li>线程1设置了ThreadLocal（thread-1 local value）</li><li>线程2设置了ThreadLocal（thread-2 local value）</li><li>线程2remove变量ThreadLocal</li><li>看看线程1是否还能打印之前设置的ThreadLocal</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">package</span> <span class="token namespace">com<span class="token punctuation">.</span>stream<span class="token punctuation">.</span>juc</span><span class="token punctuation">;</span><span class="token comment">/** * @author stream * @since 2021/9/15 16:11 */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ThreadLocalTest</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">ThreadLocal</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">></span></span> local <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ThreadLocal</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">Thread</span> threadOne <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Runnable</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token annotation punctuation">@Override</span>            <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                local<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token string">"thread-1 local value"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>                    <span class="token comment">// 等待5000毫秒，确保threadTwo 执行remove完成</span>                    <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">5000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                 <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                    e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>                <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>local<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">Thread</span> threadTwo <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Runnable</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token annotation punctuation">@Override</span>            <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                local<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token string">"thread-2 local value"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>local<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                local<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"thread-2 remove 变量local 操作完毕。"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                threadTwo<span class="token punctuation">.</span> <span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        threadOne<span class="token punctuation">.</span> <span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>执行结果<br><img src="https://img-blog.csdnimg.cn/d9aa7d2f2fd4417babdb562ef719b084.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5LiA5rGf5rqq5rC0,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><ul><li>从结果来看，在 threadTwo 执行完 remove 方法后，threadOne 仍然能够成功打印</li><li>从而证明了 ThreadLocal 的专属特性，线程独有，其他线程不可修改</li></ul><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ul><li>ThreadLocal 是解决线程安全问题一个很好的思路，</li><li>它通过为每个线程提供一个独立的变量副本解决了变量并发访问的冲突问题。</li><li>ThreadLocal 比直接使用 synchronized 同步机制解决线程安全问题更简单，更方便，且程序拥有更高的并发性。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 多线程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ThreadLocal </tag>
            
            <tag> 共享变量 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HashMap的扩容</title>
      <link href="/2021/09/12/hashmap-de-kuo-rong/"/>
      <url>/2021/09/12/hashmap-de-kuo-rong/</url>
      
        <content type="html"><![CDATA[<h2 id="HashMap初始化"><a href="#HashMap初始化" class="headerlink" title="HashMap初始化"></a>HashMap初始化</h2><p>在JDK1.8中，定义了HashMap的初始化过程，我们看看他的源码是如果定义这个初始化过程<br><img src="https://img-blog.csdnimg.cn/ef83dacd0c114c8b92ce95ee8fb5dc8f.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5LiA5rGf5rqq5rC0,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>可以看到，它的构造方法中传入了两个参数，一个是初始化容量，一个是加载因子，默认是0.75f</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">HashMap</span><span class="token punctuation">(</span><span class="token keyword">int</span> initialCapacity<span class="token punctuation">,</span> <span class="token keyword">float</span> loadFactor<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>但是这个容量最终调用了另一个构造方法<br><img src="https://img-blog.csdnimg.cn/1ba346c1aaa74ba6bb213d36903d2ba0.png" alt="在这里插入图片描述"><br>这个threshold的成员变量，就是触发HashMap扩容的阈值，当HashMap的数据量达到或超过threshold时，就会扩容。</p><p>我们再往下看这个tableSizeFor(int cap)的构造方法<br><img src="https://img-blog.csdnimg.cn/9c1e459e5575442c97e23fb351f9d51c.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5LiA5rGf5rqq5rC0,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>在 tableSizeFor(int cap)这个构造方法中，对传入的参数cap进行了多次位运算，这样可以让返回值保持在 2 的 N 次方，在扩容的时候，可以快速计算数据在扩容后的新表中的位置。</p><h2 id="HashMap-的-table-初始化"><a href="#HashMap-的-table-初始化" class="headerlink" title="HashMap 的 table 初始化"></a>HashMap 的 table 初始化</h2><p>从上面的源码大家可以发现一个问题，整个计算阈值的过程中，装载因子loadFactor并没有参与运算</p><p>实际上，在HashMap中，所有的数据都是存储在数组中，这个数组的大小就是阈值与加载因子的乘积</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">table<span class="token punctuation">.</span>size <span class="token operator">==</span> threshold <span class="token operator">*</span> loadFactor<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="HashMap的动态扩容"><a href="#HashMap的动态扩容" class="headerlink" title="HashMap的动态扩容"></a>HashMap的动态扩容</h2><ul><li>在 HashMap 中，动态扩容是 resize() 方法</li><li>这个方法了 table 的扩容，它还承担了 table 的初始化。</li></ul><p>我们先看看HashMap中put一个元素的过程，最终调用的是putVal这个方法，我们看看源码</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">final</span> <span class="token class-name">V</span> <span class="token function">putVal</span><span class="token punctuation">(</span><span class="token keyword">int</span> hash<span class="token punctuation">,</span> <span class="token class-name">K</span> key<span class="token punctuation">,</span> <span class="token class-name">V</span> value<span class="token punctuation">,</span> <span class="token keyword">boolean</span> onlyIfAbsent<span class="token punctuation">,</span>                   <span class="token keyword">boolean</span> evict<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span><span class="token punctuation">[</span><span class="token punctuation">]</span> tab<span class="token punctuation">;</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span> p<span class="token punctuation">;</span> <span class="token keyword">int</span> n<span class="token punctuation">,</span> i<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>tab <span class="token operator">=</span> table<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> <span class="token punctuation">(</span>n <span class="token operator">=</span> tab<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>            n <span class="token operator">=</span> <span class="token punctuation">(</span>tab <span class="token operator">=</span> <span class="token function">resize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span>length<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>p <span class="token operator">=</span> tab<span class="token punctuation">[</span>i <span class="token operator">=</span> <span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> hash<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>            tab<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">newNode</span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>            <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span> e<span class="token punctuation">;</span> <span class="token class-name">K</span> k<span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>p<span class="token punctuation">.</span>hash <span class="token operator">==</span> hash <span class="token operator">&amp;&amp;</span>                <span class="token punctuation">(</span><span class="token punctuation">(</span>k <span class="token operator">=</span> p<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token operator">==</span> key <span class="token operator">||</span> <span class="token punctuation">(</span>key <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> key<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                e <span class="token operator">=</span> p<span class="token punctuation">;</span>            <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>p <span class="token keyword">instanceof</span> <span class="token class-name">TreeNode</span><span class="token punctuation">)</span>                e <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span><span class="token punctuation">)</span>p<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">putTreeVal</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> tab<span class="token punctuation">,</span> hash<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>                <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> binCount <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token punctuation">;</span> <span class="token operator">++</span>binCount<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>e <span class="token operator">=</span> p<span class="token punctuation">.</span>next<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                        p<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token function">newNode</span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token keyword">if</span> <span class="token punctuation">(</span>binCount <span class="token operator">>=</span> TREEIFY_THRESHOLD <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token comment">// -1 for 1st</span>                            <span class="token function">treeifyBin</span><span class="token punctuation">(</span>tab<span class="token punctuation">,</span> hash<span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token keyword">break</span><span class="token punctuation">;</span>                    <span class="token punctuation">&#125;</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>e<span class="token punctuation">.</span>hash <span class="token operator">==</span> hash <span class="token operator">&amp;&amp;</span>                        <span class="token punctuation">(</span><span class="token punctuation">(</span>k <span class="token operator">=</span> e<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token operator">==</span> key <span class="token operator">||</span> <span class="token punctuation">(</span>key <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> key<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                        <span class="token keyword">break</span><span class="token punctuation">;</span>                    p <span class="token operator">=</span> e<span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>            <span class="token punctuation">&#125;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>e <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// existing mapping for key</span>                <span class="token class-name">V</span> oldValue <span class="token operator">=</span> e<span class="token punctuation">.</span>value<span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>onlyIfAbsent <span class="token operator">||</span> oldValue <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>                    e<span class="token punctuation">.</span>value <span class="token operator">=</span> value<span class="token punctuation">;</span>                <span class="token function">afterNodeAccess</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">return</span> oldValue<span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token operator">++</span>modCount<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">++</span>size <span class="token operator">></span> threshold<span class="token punctuation">)</span>            <span class="token function">resize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">afterNodeInsertion</span><span class="token punctuation">(</span>evict<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在resize()中，它调整了扩容阈值threshold，并且完成了对table的初始化。我们看看resize()的源码</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">final</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">resize</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span><span class="token punctuation">[</span><span class="token punctuation">]</span> oldTab <span class="token operator">=</span> table<span class="token punctuation">;</span>        <span class="token keyword">int</span> oldCap <span class="token operator">=</span> <span class="token punctuation">(</span>oldTab <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token number">0</span> <span class="token operator">:</span> oldTab<span class="token punctuation">.</span>length<span class="token punctuation">;</span>        <span class="token keyword">int</span> oldThr <span class="token operator">=</span> threshold<span class="token punctuation">;</span>        <span class="token keyword">int</span> newCap<span class="token punctuation">,</span> newThr <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>oldCap <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>oldCap <span class="token operator">>=</span> MAXIMUM_CAPACITY<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                threshold <span class="token operator">=</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span>MAX_VALUE<span class="token punctuation">;</span>                <span class="token keyword">return</span> oldTab<span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>newCap <span class="token operator">=</span> oldCap <span class="token operator">&lt;&lt;</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> MAXIMUM_CAPACITY <span class="token operator">&amp;&amp;</span>                     oldCap <span class="token operator">>=</span> DEFAULT_INITIAL_CAPACITY<span class="token punctuation">)</span>                newThr <span class="token operator">=</span> oldThr <span class="token operator">&lt;&lt;</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">// double threshold</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>oldThr <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token comment">// initial capacity was placed in threshold</span>        <span class="token comment">//当我们指定了初始容量，且 table 未被初始化时，oldThr 就不为 0，</span>        <span class="token comment">//将 newCap 赋值为 oldThr，新创建的 table 会是我们构造的 HashMap 时指定的容量值。</span>            newCap <span class="token operator">=</span> oldThr<span class="token punctuation">;</span>        <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>               <span class="token comment">// zero initial threshold signifies using defaults</span>            newCap <span class="token operator">=</span> DEFAULT_INITIAL_CAPACITY<span class="token punctuation">;</span>            newThr <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">(</span>DEFAULT_LOAD_FACTOR <span class="token operator">*</span> DEFAULT_INITIAL_CAPACITY<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>newThr <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">//通过装载因子（loadFactor）调整了新的阈值（newThr）</span>            <span class="token keyword">float</span> ft <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">float</span><span class="token punctuation">)</span>newCap <span class="token operator">*</span> loadFactor<span class="token punctuation">;</span>            newThr <span class="token operator">=</span> <span class="token punctuation">(</span>newCap <span class="token operator">&lt;</span> MAXIMUM_CAPACITY <span class="token operator">&amp;&amp;</span> ft <span class="token operator">&lt;</span> <span class="token punctuation">(</span><span class="token keyword">float</span><span class="token punctuation">)</span>MAXIMUM_CAPACITY <span class="token operator">?</span>                      <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span>ft <span class="token operator">:</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span>MAX_VALUE<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token comment">// 使用 loadFactor 调整后的阈值，重新保存到 threshold 中</span>        threshold <span class="token operator">=</span> newThr<span class="token punctuation">;</span>        <span class="token annotation punctuation">@SuppressWarnings</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span><span class="token string">"rawtypes"</span><span class="token punctuation">,</span><span class="token string">"unchecked"</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span>        <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span><span class="token punctuation">[</span><span class="token punctuation">]</span> newTab <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token punctuation">[</span>newCap<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token comment">//通过 newCap 创建新的数组，将其指定到 table 上，完成 table 的初始化</span>        table <span class="token operator">=</span> newTab<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>oldTab <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> oldCap<span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span> e<span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>e <span class="token operator">=</span> oldTab<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                    oldTab<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>e<span class="token punctuation">.</span>next <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>                        newTab<span class="token punctuation">[</span>e<span class="token punctuation">.</span>hash <span class="token operator">&amp;</span> <span class="token punctuation">(</span>newCap <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">=</span> e<span class="token punctuation">;</span>                    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>e <span class="token keyword">instanceof</span> <span class="token class-name">TreeNode</span><span class="token punctuation">)</span>                        <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span><span class="token punctuation">)</span>e<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> newTab<span class="token punctuation">,</span> j<span class="token punctuation">,</span> oldCap<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token keyword">else</span> <span class="token punctuation">&#123;</span> <span class="token comment">// preserve order</span>                        <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span> loHead <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">,</span> loTail <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>                        <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span> hiHead <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">,</span> hiTail <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>                        <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span> next<span class="token punctuation">;</span>                        <span class="token keyword">do</span> <span class="token punctuation">&#123;</span>                            next <span class="token operator">=</span> e<span class="token punctuation">.</span>next<span class="token punctuation">;</span>                            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>e<span class="token punctuation">.</span>hash <span class="token operator">&amp;</span> oldCap<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                                <span class="token keyword">if</span> <span class="token punctuation">(</span>loTail <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>                                    loHead <span class="token operator">=</span> e<span class="token punctuation">;</span>                                <span class="token keyword">else</span>                                    loTail<span class="token punctuation">.</span>next <span class="token operator">=</span> e<span class="token punctuation">;</span>                                loTail <span class="token operator">=</span> e<span class="token punctuation">;</span>                            <span class="token punctuation">&#125;</span>                            <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>                                <span class="token keyword">if</span> <span class="token punctuation">(</span>hiTail <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>                                    hiHead <span class="token operator">=</span> e<span class="token punctuation">;</span>                                <span class="token keyword">else</span>                                    hiTail<span class="token punctuation">.</span>next <span class="token operator">=</span> e<span class="token punctuation">;</span>                                hiTail <span class="token operator">=</span> e<span class="token punctuation">;</span>                            <span class="token punctuation">&#125;</span>                        <span class="token punctuation">&#125;</span> <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>e <span class="token operator">=</span> next<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token keyword">if</span> <span class="token punctuation">(</span>loTail <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                            loTail<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>                            newTab<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> loHead<span class="token punctuation">;</span>                        <span class="token punctuation">&#125;</span>                        <span class="token keyword">if</span> <span class="token punctuation">(</span>hiTail <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                            hiTail<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>                            newTab<span class="token punctuation">[</span>j <span class="token operator">+</span> oldCap<span class="token punctuation">]</span> <span class="token operator">=</span> hiHead<span class="token punctuation">;</span>                        <span class="token punctuation">&#125;</span>                    <span class="token punctuation">&#125;</span>                <span class="token punctuation">&#125;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> newTab<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>所有我们传递进来的 initialCapacity 虽然经过 tableSizeFor() 方法调整后，直接赋值给 threshold</li><li>但是它实际是 table 的大小，并且最终会通过 loadFactor 重新调整 threshold。</li></ul><h2 id="经典面试题"><a href="#经典面试题" class="headerlink" title="经典面试题"></a>经典面试题</h2><h3 id="计划用HashMap存1k条数据，构造时传1000会触发扩容吗"><a href="#计划用HashMap存1k条数据，构造时传1000会触发扩容吗" class="headerlink" title="计划用HashMap存1k条数据，构造时传1000会触发扩容吗"></a>计划用HashMap存1k条数据，构造时传1000会触发扩容吗</h3><ul><li> HashMap 初始容量指定为 1000，会被 tableSizeFor() 调整为 1024；</li><li>但是它只是表示 table 数组为 1024；</li><li>负载因子是0.75，扩容阈值会在 resize() 中调整为 768（1024 * 0.75）</li><li>会触发扩容</li></ul><p>如果需要存储1k的数据，应该传入1000 / 0.75(1333)</p><ul><li>tableSizeFor() 方法调整到 2048，不会触发扩容。</li></ul><h3 id="计划用HashMap存1w条数据，构造时传10000会触发扩容吗"><a href="#计划用HashMap存1w条数据，构造时传10000会触发扩容吗" class="headerlink" title="计划用HashMap存1w条数据，构造时传10000会触发扩容吗"></a>计划用HashMap存1w条数据，构造时传10000会触发扩容吗</h3><ul><li>当我们构造HashMap时，参数传入进来 1w </li><li>经过 tableSizeFor() 方法处理之后，就会变成 2 的 14 次幂 16384</li><li>负载因子是 0.75f，可存储的数据容量是 12288（16384 * 0.75f）</li><li>完全够用，不会触发扩容</li></ul>]]></content>
      
      
      <categories>
          
          <category> Java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HashMap </tag>
            
            <tag> 扩容 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL索引(二)</title>
      <link href="/2021/09/05/mysql-suo-yin-er/"/>
      <url>/2021/09/05/mysql-suo-yin-er/</url>
      
        <content type="html"><![CDATA[<h1 id="MySQL索引-二"><a href="#MySQL索引-二" class="headerlink" title="MySQL索引(二)"></a>MySQL索引(二)</h1><h2 id="自适应哈希索引"><a href="#自适应哈希索引" class="headerlink" title="自适应哈希索引"></a>自适应哈希索引</h2><ul><li>自适应哈希索引是InnoDB引擎的一个特殊功能，当它注意到某些索引值被使用的非常频繁时，会在内<br>存中基于B-Tree索引之上再创键一个哈希索引，这样就让B-Tree索引也具有哈希索引的一些优点，比<br>如快速哈希查找</li><li>这是一个完全自动的内部行为，用户无法控制或配置，但如果有必要可以关闭该功能。</li></ul><h2 id="空间索引"><a href="#空间索引" class="headerlink" title="空间索引"></a>空间索引</h2><ul><li>MyISAM的表支持空间索引，可以用作地理数据存储</li><li>和B-Tree索引不同，这类索引无需前缀查询。</li><li>空间索引会从所有维度来索引数据，查询时可以有效地使用任意维度来组合查询。</li><li>必须使用MySQL的GIS即地理信息系统的相关函数来维护数据</li><li>MySQL对地理信息的支持并不完善，因此大基本不会使用这种索引。</li></ul><h2 id="全文索引"><a href="#全文索引" class="headerlink" title="全文索引"></a>全文索引</h2><p>通过数值比较、范围过滤等就可以完成绝大多数需要的查询，但如果希望通过关键字匹配进行查询，就<br>需要基于相似度的查询，而不是精确的数值比较，全文索引就是为这种场景设计的。</p><ul><li>MyISAM的全文索引是一种特殊的B-Tree索引，共有两层</li><li>第一层是所有关键字，然后对于每一个关键字的第二层，包含的是一组相关的”文档指针”。</li><li>全文索引不会索引文档对象中的所有词语，它会根据规则过滤掉一些词语</li></ul><h2 id="聚簇索引"><a href="#聚簇索引" class="headerlink" title="聚簇索引"></a>聚簇索引</h2><p>聚簇索引并不是一种索引类型，而是一种数据存储方式。InnoDB 的聚簇索引实际上在同一个结构中保存<br>了B-Tree索引和数据行。当表有聚餐索引时，它的行数据实际上存放在索引的叶子页中，因为无法同<br>时把数据行存放在两个不同的地方，所以一个表只能有一个聚簇索引。聚簇索引也叫主键索引</p><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ul><li>可以把相关数据保存在一起，将数据放在索引树的叶子节点下，找到叶子就可以找到数据</li><li>数据访问更快，聚簇索引将索引和数据保存在同一个B-Tree中，因此获取数据比非聚簇索引要更快。</li><li>使用覆盖索引扫描的查询可以直接使用页节点中的主键值。<h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4></li><li>聚簇索引最大限度提高了IO密集型应用的性能，如果数据全部在内存中将会失去优势</li><li>更新聚簇索引列的代价很高，因为会强制每个被更新的行移动到新位置</li><li>基于聚簇索引的表插入新行或主键被更新导致行移动时，可能导致页分裂，表会占用更多磁盘空间</li><li>当行稀疏或由于页分裂导致数据存储不连续时，全表扫描可能很慢。</li></ul><h2 id="非聚簇索引"><a href="#非聚簇索引" class="headerlink" title="非聚簇索引"></a>非聚簇索引</h2><ul><li>非聚簇索引是在索引树的叶子节点上存放数据的地址，找到该地址后，需要到磁盘中查询一次才能获取到数据。</li><li>MyISAM存储引擎的索引方式就是非聚簇索引，只在索引树的叶子节点上存放地址。</li></ul><h4 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h4><ul><li>在InnoDB 里，索引 B+Tree 的叶子节点存储了”整行数据”的是主键索引，也被称之为聚簇索引</li><li>索引B+Tree的叶子节点只存储了”主键的值和索引列”的是非主键索引，也被称之为非聚簇索引</li></ul><h2 id="索引覆盖"><a href="#索引覆盖" class="headerlink" title="索引覆盖"></a>索引覆盖</h2><p>覆盖索引指一个索引包含或覆盖了所有需要查询的字段的值，不再需要根据索引回表查询数据。覆盖索<br>引必须要存储索引列的值，因此MySQL只能使用B-Tree索引做覆盖索引。</p><h4 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h4><ul><li>索引条目通常远小于数据行大小，可以极大减少数据访问量</li><li>因为索引按照列值顺序存储，所以对于IO密集型防伪查询回避随机从磁盘读取每一行数据的IO少得多</li><li>由于InnoDB使用.聚簇索引，覆盖索引对InnoDB很有帮助。InnoDB 的二级索引在叶子节点保存了行的主键值，如果二级主键能覆盖查询那么可以避免对主键索引的二次查询。</li></ul><h2 id="什么情况下索引失效"><a href="#什么情况下索引失效" class="headerlink" title="什么情况下索引失效"></a>什么情况下索引失效</h2><ul><li>模糊查询 %like</li><li>索引列参与计算,使用了函数</li><li>非最左前缀顺序</li><li>where单列索引对null判断 </li><li>where不等于</li><li>or操作有至少一个字段没有索引</li><li>需要回表的查询结果集过大（超过配置的范围）</li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
            <tag> 索引 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TCP三次握手和四次挥手</title>
      <link href="/2021/09/05/tcp-san-ci-wo-shou-he-si-ci-hui-shou/"/>
      <url>/2021/09/05/tcp-san-ci-wo-shou-he-si-ci-hui-shou/</url>
      
        <content type="html"><![CDATA[<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><h4 id="SYN-Synchronize-Sequence-Numbers"><a href="#SYN-Synchronize-Sequence-Numbers" class="headerlink" title="SYN-(Synchronize Sequence Numbers)"></a>SYN-(Synchronize Sequence Numbers)</h4><ul><li>同步序列编号。是TCP/IP建立连接时使用的握手信号。在客户机和服务器之间建立TCP连接时，首先会发送的一个信号。客户端在接受到SYN消息时，就会在自己的段内生成一个随机值seq=x。<h4 id="ACK-Acknowledge-character"><a href="#ACK-Acknowledge-character" class="headerlink" title="ACK-(Acknowledge character)"></a>ACK-(Acknowledge character)</h4></li><li>确认字符，表示发来的数据已确认接收无误。最后，客户端将ACK发送给服务器。序列号被设置为所接收的确认值即Y + 1。<h4 id="SYN-ACK"><a href="#SYN-ACK" class="headerlink" title="SYN-ACK"></a>SYN-ACK</h4></li><li>服务器收到SYN后，打开客户端连接，发送一个SYN-ACK作为答复。确认号设置为比接收到的序列号多一个，即X+ 1，服务器为数据包选择的序列号是另一个随机数Y。<h4 id="FIN"><a href="#FIN" class="headerlink" title="FIN"></a>FIN</h4></li><li>用于断开连接的</li></ul><h2 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h2><h4 id="三次握手过程"><a href="#三次握手过程" class="headerlink" title="三次握手过程"></a>三次握手过程</h4><p>建立TCP连接需要进行三次握手，分配初始序列号和资源，在相互确认之后才开始数据的传输。握手初始化了传输可靠性以及数据顺序性必要的信息，这些信息包括两个方向的初始序列号，确认号由初始序列号生成，使用3次握手是因为3次握手已经准备好了传输可靠性以及数据顺序性所必要的信息</p><ul><li>客户端主动打开</li><li>服务端被动打开</li></ul><h3 id="握手过程"><a href="#握手过程" class="headerlink" title="握手过程"></a>握手过程</h3><p><img src="https://img-blog.csdnimg.cn/64eada28b1244e1a93be6d2a1cf55a71.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5LiA5rGf5rqq5rC0,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><ul><li><p>第一次握手:客户端将标志位SYN置为1，随机产生一个值序列号seq=x，并将该数据包发送给服务端，客户端进入syn_sent状态，等待服务端确认。</p></li><li><p>第二次握手:服务端收到数据包后由标志位SYN=1知道客户端请求建立连接，服务端将标志位SYN和 ACK都置为1，ack=x+1,随机产生一个值seq=y，并将该数据包发送给客户端以确认连接请求，服务端进入syn_rcvd状态。</p></li><li><p>第三次握手:客户端收到确认后检查,如果正确则将标志位ACK为1，ack=y+1，并将该数据包发送给服务端，服务端进行检查如果正确则连接建立成功，客户端和服务端进入established状态，完成三次握手，随后客户端和服务端之间可以开始传输数据了</p></li></ul><h4 id="为什么需要三次握手"><a href="#为什么需要三次握手" class="headerlink" title="为什么需要三次握手"></a>为什么需要三次握手</h4><ul><li>TCP的连接是发送消息两个方向的连接都要建立成功。</li><li>如果要保证双向连接都成功的话，三次通信是最少的次数了。</li><li>大于三次的话，后面的次数通信就没有必要了，是在浪费资源。</li></ul><h2 id="TCP四次挥手"><a href="#TCP四次挥手" class="headerlink" title="TCP四次挥手"></a>TCP四次挥手</h2><p>断开TCP连接需要四次挥手</p><h4 id="挥手过程"><a href="#挥手过程" class="headerlink" title="挥手过程"></a>挥手过程</h4><p><img src="https://img-blog.csdnimg.cn/d6b11ef8598a4a78b47dfe037816ebfd.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5LiA5rGf5rqq5rC0,size_15,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><ul><li><p>第一次挥手：客户端发送一个FIN，用来关闭客户端到服务端的数据传送，客户端进入finwait1状态。</p></li><li><p>第二次挥手：服务端收到FIN后，发送一个ACK给客户端，确认序号为收到序号+1，服务端进入Close_wait状态。此时TCP连接处于半关闭状态，即客户端已经没有要发送的数据了，但服务端若发送数据，则客户端仍要接收。</p></li><li><p>第三次挥手：服务端发送一个FIN，用来关闭服务端到客户端的数据传送，服务端进入Last_ack状态。</p></li><li><p>第四次挥手：客户端收到FIN后，客户端进入Time_wait状态，接着发送一个ACK给服务端，确认后，服务端进入Closed状态，完成四次挥手。</p></li></ul><h4 id="为什么要四次挥手"><a href="#为什么要四次挥手" class="headerlink" title="为什么要四次挥手"></a>为什么要四次挥手</h4><ul><li>任何一方都可以在数据传送结束后发出连接释放的通知，待对方确认后进入半关闭状态。</li><li>当另一方也没有数据再发送的时候，则发出连接释放通知，对方确认后就完全关闭了TCP连接。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TCP </tag>
            
            <tag> 三次握手 </tag>
            
            <tag> 四次挥手 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
